## 题目

> [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

 

示例 1：

```
输入: n = 3
输出: 6
```


示例 2：

```
输入: n = 9
输出: 45
```


限制：

* 1 <= n <= 10000



## 解题思路

### 逻辑短路

> 正常人的解法

如果去掉题目中禁止使用 `if  else` 的条件, 可以想到用递归实现

```java
public int sumNums(int n) {
	
    return n>0?n + sumNums(n-1):0;
    
}
```

但是题目禁止使用 `if else` .  除了 `if else` , 我们还有第二种方案, 那就是逻辑运算符的短路性质. 我们需要在 `n = 0` 时短路, 禁止递归. 那么逻辑写法应该是 `boolean res = n != 0 &&  (n += sumNums(n-1) ) > 0 ;`,  如此一来当 `n` 减至 `0` 时, 会终止递归.

```java
public int sumNums(int n) {
	
    boolean  flag = n != 0 && (n += sumNums(n-1)) >0;
    return n;
    
}
```

> 这样代码就会在 `n = 0` 时, 截断, 终止递归

### 俄罗斯乘法

> 转载至 -[快速乘（俄罗斯农民乘法）](https://cloud.tencent.com/developer/article/1643157)

-----

算法原理:

先看看我们笔算乘法是怎么计算的：

````
   88
x  99
----------
  792
+792
----------
 8712
````

这个过程可以用公式表达为:

```
88 * 99 = 88 * 9 * 10^0 + 88 * 9 * 10^1
        = 792 + 7920
        = 8712
```

根据这个原理，我们把第二个乘数换成二进制：

```
88 * 0110 0011(2) = 88 * 0 * 2^7 
                  + 88 * 1 * 2^6 
                  + 88 * 1 * 2^5 
                  + 88 * 0 * 2^4 
                  + 88 * 0 * 2^3 
                  + 88 * 0 * 2^2 
                  + 88 * 1 * 2^1
                  + 88 * 1 * 2^0
```

-------

算法用途:

* 通常用在大数相乘取模的情况，可以防止大数相乘溢出。
*  当我们使用 int类型做快速乘运算时就相当于模2^32（假设 int类型是 4位）。

-----

代码实现

```java
int quickMulti(int A, int B) {
    int ans = 0;
    for ( ; B; B >>= 1) {
        if (B & 1) {
            ans += A;
        }
        A <<= 1;
    }
    return ans;
}
```

-----

回到题目, 已知 `1+2+...n` , 最后的结果是 `(n(n+1))/2` ,  `n * (n + 1)` 我们可以用俄罗斯乘法实现, 而 除以2可以用右移1位实现.

所以代码如下

```java
class Solution {
   
    public int sumNums(int n) {

        int ans = 0; int a = n; int b = n + 1;

        boolean flag =  (b & 1 ) > 0 && (ans += a) > 1; // 1次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 2次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 3 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 4 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 5 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 6 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 7 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 8次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 9 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 10 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 11 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 12 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 13 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 14 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 15 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 16 次
        b >>= 1; a <<= 1;

        flag =  (b & 1 ) > 0 && (ans += a) > 1 ; // 17 次
        b >>= 1; a <<= 1;

        return ans >> 1;
    
    }
}
```

> `int` 型变量应该运算 32 次, 但是本题中数值不是很大, 所以右移 10 几次就可以了.