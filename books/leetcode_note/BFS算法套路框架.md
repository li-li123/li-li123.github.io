## 回溯算法解题套路框架
> 本节摘抄自 《labuladong的算法小抄》
-----

BFS(Breath First Search, 广度优先搜索)和DFS(Depth First Search, 深度优先搜索)算法是特别常用的两种算法，**其中DFS可以被认为是回溯算法**。

本节就来写BFS算法的框架套路。BFS算法的核心应该不难理解，**就是把一些问题抽象成图，从一个点开始，向四周扩散。**一般来说，我们谢BFS算法都是用"队列"这种数据结构，每次将一个节点周围的所有节点加入队列。

`BFS`相对`DFS`的最主要的区别是: **BFS的路径一定是最短的，但代价是空间复杂度比DFS大的多**，至于为什么看过后面的介绍的框架就很容易理解了。

本节以“二叉树的最小高度”为例解释BFS典型题目

-------

## 算法框架

要说框架的话，我们先列举一下BFS常见的出现场景把。**问题的本质就是让你在副"图"中找到从起点`start`到终点`target`的最近距离，这个例子听起啦很枯燥，但是BFS算法问题其实就是干这件事**。把枯燥的本质搞清楚了，再去欣赏各种问题的包装才能胸有成竹。

这个广义的描述可以有这种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短举例是多少？如果这个迷宫带“传送带”可以瞬间传送呢?

在比如有两个单词，要求通过替换某些字母，把其中一个变成另一个，每次只能替换一个字母，最少要替换几次。

在比如连连看游戏，消除两个方块的条件不仅是图案相同，还要保证两个方块之间的最短连线不能多个两个拐点。你玩连连看，点击两个坐标，**游戏程序如何找到最颠连线有几个拐点？**

在比如……

其实，这些问题都没啥神奇的，本质就是一幅"图", **让你从起点走到终点，问最短路径**，这就是BFS的本质。

框架搞清楚了直接默写就好，记住下面这段代码就行了:

------

```java
// 计算从起点start到终点target的最短距离
def BFS(Node start, Node target){
    Queue<Node> q; // 核心数据结构，记录下一步到达的节点
    Set<Node> visited; // 避免走回头路
    
    q.offer(start); // 将起点加入队列
    visited.add(start); 
    int step = 0; // 记录步数
    
    while(q not empty){
        
        int sz = q.size();
        // 将当前节点队列中的所有节点向四周扩散
        for(int i=0; i<sz; i++){
           
            Node cur = q.poll();
            // 划重点: 这里判断是否到达终点
            if( cur is target){
                return step;
            }
            // 将cur的相邻节点加入队列
            for(Node x: cur.adj()){
                if(x not in visited){
                    a.offer(x);
                    visited.add(x);
                   
                }
            }
            
        }
        // 划重点: 这里更新步数
        step ++;
	}
}
```

-------

队列`q`就不说了，是BFS的核心数据结构；`cur.adj()`泛指与`cur`相邻的节点，比如在二维数组中，`cur`上下左右四面的位置就是相邻节点；`visited`的主要作用就是防止走回头路，大部分时候都是必须的，**但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回退路就不需要`visited`。**

## 二叉树的最小高度

先来一个简单的问题实践一下BFS框架吧,我们都做过二叉树最大深度的算法题。**现在让你计算一颗二叉树的最小高度**:

输入一棵二叉树，请计算它的最小高度，也就是根节点到叶子节点的最短距离。怎么套到BFS框架里面呢？首先明确起点`start`和终点`target`是什么，以及怎么判断到达了终点。

**显然起点就是root根节点，终点就是最靠近根节点的那个“叶子节点”**，叶子节点就是两个都是`null`的节点。

----

```java
if(cur.left == null && cur.right == null)
    //到达叶子节点
```

----

那么按照上述框架稍加改造来写解法即可:

-----

```java
int minDepth(TreeNode root){

        Queue<TreeNode> queue = new ArrayDeque<>();
        Set<TreeNode> visited = new HashSet<>();
        queue.add(root);
        visited.add(root);
        int step = 1; // root 本身就是1层，将depth初始化为1;

        while (!queue.isEmpty()){
            int size = queue.size();
            
            // 将当前节点队列中的所有节点向四周扩散
            for (int i = 0; i < size; i++) {
                TreeNode temp = queue.poll();
                if(temp == null){ return  -1;}
                
                // 划重点: 这里判断是否到达终点
                if(temp.left == null && temp.right == null){
                    return step;
                }
                // 将cur的相邻节点加入队列
                if(temp.left!=null && !visited.contains(temp.left)){
                    queue.add(temp.left);
                    visited.add(temp.left);
                }
                if(temp.right!=null && !visited.contains(temp.right)){
                    queue.add(temp.right);
                    visited.add(temp.right);
                }

            }
            // 划重点: 这里更新步数
            step ++;

        }

        return -1;
    }
```

> 其实上述代码中，不如添加`visited`，因为二叉树不会走回头路

----

二叉树是很简单的数据结构，上述代码应该可以理解吧，其实其他复杂问题就是这个框架的变形，在探讨复杂问题之前，先解答两个问题。

1. **为什么BFS可以找到最短距离，DFS不行吗**

首先，你要看BFS的逻辑，`depth`每增加一次，队列中的所有节点都向前迈一步，这个逻辑保证一旦找到一个终点，走的步数是最少的。BFS算法的时间复杂度最坏情况下是O(N)。

DFS不能找到最短路径吗？**其实也是可以的，时间复杂度也是O(N)，但是实际上比BFS低效很多。**你想啊，DFS实际上是靠递归的堆栈记录走过的路径的，你要找到最短路劲肯定要把二叉树中所有的树杈都探索完，然后才能对比出最短路径有多长，对不对?而BFS借助队列做到一步一步“齐头并进”，是可以在还没遍历完整棵树的时候就找到最短路径的。所以说虽然二者在`Big O`衡量标准下，最坏时间复杂度相同，但实际上BFS肯定更高效。

形象点说，DFS是线，BFS是面，DFS是单打独斗；BFS是集体行动，这下应该很容易理解了吧

2. **既然BFS那么好，为啥DFS还要存在？**

BFS可以找到最短距离，但是空间复杂度高，而DFS的空间复杂度较低。

还看刚才我们处理二叉树问题的例子，假设给你这棵二叉树是满二叉树，节点数为N，对于DFS算法来说，空间复杂度无非就是递归堆栈，在最坏的情况下顶多就是树的高度，也就是`O(logN)`。但是对于BFS算法，队列中每次都会存储二叉树一层的节点，这样在最坏情况下空间复杂度应该是树的最下层节点的数量。也就是`N/2`。用`Big O`表示，的话就是`O(N)`

由此观之，BFS还是有代价的，一般来说在找最短路径的时候使用BFS，其他时候还是使用DFS用的多，其他时候还是DFS用的多写(主要是递归代码好写)。

