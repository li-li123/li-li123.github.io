## 题目
> [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

进阶：

你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

**示例 1**

<div><center>
<img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/sort_list_1.jpg" alt="sort_list_1" style="zoom:50%;" />
</center></div>


```text
输入：head = [4,2,1,3]
输出：[1,2,3,4]

```

**示例 2**

<div><center>
<img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/sort_list_2.jpg" alt="sort_list_2" style="zoom:50%;" />
</center></div>

```text
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例 3**

```text
输入：head = []
输出：[]
```

**提示：**

- 链表中节点的数目在范围 `[0, 5 * 104]` 内
- `-105 <= Node.val <= 105`

## 解题思路

题目要求使用插入排序的方法对链表进行排序，插入排序的时间复杂度是 O(n^2),其中 n 是链表的长度。这道题考虑时间复杂度更低的排序算法。题目的进阶问题要求达到 `O(nlog n)` 的时间复杂度和`O(1)`的空间复杂度，时间复杂度是`O(n log n)`的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是`O(n^2)`)，其中最适合链表的排序算法是归并排序。

归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是`O(log n)`。如果要达到`O(1)`的空间复杂度，则需要使用自底向上的实现方式。

*****

**方法一: 自顶向下归并排序**

1. 对链表自顶向下归并排序的过程如下。
2. 找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 `2` 步，慢指针每次移动`1`步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。
3. 对两个子链表分别排序。

将两个排序后的子链表合并，得到完整的排序后的链表。可以使用的做法，将两个有序的子链表进行合并。

******

**方法二: 自底向上归并排序**

使用自底向上的方法实现归并排序，则可以达到 O(1) 的空间复杂度。首先求得链表的长度 length，然后将链表拆分成子链表进行合并。

具体做法如下。

1. 用`subLength` 表示每次需要排序的子链表的长度，初始时 `subLength=1`。

2. 每次将链表拆分成若干个长度为`subLength` 的子链表（最后一个子链表的长度可以小于`subLength`），按照每两个子链表一组进行合并，合并后即可得到若干个长度为`subLength×2 `的有序子链表（最后一个子链表的长度可以小于`subLength×2`）。合并两个子链表仍然使用合并两个有序链表的做法。

3. 将`subLength `的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于 length，整个链表排序完毕。



如何保证每次合并之后得到的子链表都是有序的呢？可以通过数学归纳法证明。

1. 初始时`subLength=1`，每个长度为 11 的子链表都是有序的。
2. 如果每个长度为`subLength `的子链表已经有序，合并两个长度为`subLength` 的有序子链表，得到长度为`subLength×2 `的子链表，一定也是有序的。
3. 当最后一个子链表的长度小于 `subLength `时，该子链表也是有序的，合并两个有序子链表之后得到的子链表一定也是有序的。

## 解题代码

### 自顶向下归并排序

```java
public ListNode sortList(ListNode head) {
    return solve(head);
}
/**
* 链表归并排序
*/
public ListNode solve(ListNode head){
    if(head != null){

        // 找到链表中点
        ListNode middleNode = findMiddleNode(head);
        if(middleNode.next == null) return middleNode;
        
        // 截断中点，使一个链表成为两个链表
       	ListNode right = middleNode.next;
        middleNode.next = null;
        
        
        ListNode leftResult = solve(head);
        ListNode rightResult = solve(right);
        return merge(leftResult, rightResult);

    }
    return null;
}

/**
* 快慢指针找到链表中点
*/
public ListNode findMiddleNode(ListNode head){

    if(head == null || head.next == null || head.next.next==null) return head;
    ListNode slow = head;
    ListNode fast = head.next;
    
    while (true){
        
        slow = slow.next;
        if(fast.next==null || fast.next.next==null){
            return slow;
        }
        fast = fast.next.next;
        if(slow == fast)
            return null;
    }
    

}

/**
* 归并两个有序链表
*/
public ListNode merge(ListNode left, ListNode right){
    ListNode cache = new ListNode(0);
    ListNode cacheTemp = cache, leftTemp = left, rightTemp = right;
    while (leftTemp!=null&&rightTemp!=null){
        if(leftTemp.val<rightTemp.val){
            cacheTemp.next = leftTemp;
            cacheTemp = cacheTemp.next;
            leftTemp = leftTemp.next;
        }else {
            cacheTemp.next = rightTemp;
            cacheTemp = cacheTemp.next;
            rightTemp = rightTemp.next;
        }
    }
    if(leftTemp != null){
        cacheTemp.next = leftTemp;
    }
    if(rightTemp!=null){
        cacheTemp.next = rightTemp;
    }
    return cache.next;

}
```

> 复杂度分析
>
> 时间复杂度：`O(nlogn)`，其中 n 是链表的长度。
>
> 空间复杂度：`O(logn)`，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间。
>

<div>
    <center><span style="color:red"> 递归可以使用返回值，进行传值和保存状态 </span></center>
</div>

### 子底向上归并排序

```java
public ListNode sortList(ListNode head) {
    if (head == null) {
        return head;
    }
    int length = 0;
    ListNode node = head;
    while (node != null) {
        length++;
        node = node.next;
    }
    ListNode dummyHead = new ListNode(0, head);

    for (int subLength = 1; subLength < length; subLength <<= 1) {

        ListNode prev = dummyHead, curr = dummyHead.next;
        while (curr != null) {

            // 截断第一段
            ListNode head1 = curr;
            for (int i = 1; i < subLength && curr.next != null; i++) {
                curr = curr.next;
            }
            ListNode head2 = curr.next;
            curr.next = null;

            // 截断第二段
            curr = head2;
            for (int i = 1; i < subLength && curr != null && curr.next != null; i++) {
                curr = curr.next;
            }
            ListNode next = null; // 记录下次开始截断的位置
            if (curr != null) {
                next = curr.next;
                curr.next = null;
            }


            ListNode merged = merge(head1, head2);

            // 重组链表
            prev.next = merged;
            while (prev.next != null) {
                prev = prev.next;
            }

            curr = next;

        }
    }
    return dummyHead.next;
}

public ListNode merge(ListNode head1, ListNode head2) {
    ListNode dummyHead = new ListNode(0);
    ListNode temp = dummyHead, temp1 = head1, temp2 = head2;
    while (temp1 != null && temp2 != null) {
        if (temp1.val <= temp2.val) {
            temp.next = temp1;
            temp1 = temp1.next;
        } else {
            temp.next = temp2;
            temp2 = temp2.next;
        }
        temp = temp.next;
    }
    if (temp1 != null) {
        temp.next = temp1;
    } else if (temp2 != null) {
        temp.next = temp2;
    }
    return dummyHead.next;
}
```

