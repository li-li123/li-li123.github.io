## 索引是什么

MySQL官方对索引的定义为：索引(Index)是帮助MySQL高校获取数据的数据结构。数据库所存的数据之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据的基础上实现高级查找算法，这种数据结构就是索引。

> 可以得到索引的本质： 索引是数据结构，类似**排好序的快速查找数据结构**
>
> 索引的目的在于提高查询效率，可以类比字典。如果要查"mysql"这个单词，我们肯定需要定位到m字母，然后从下往上找到y字母，再找剩下sql。如果没有索引，**那么你可能需要a-z，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？**

索引详解：

在数据之外，**数据库系统还维护着满足特定查找算法的数据结构**，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

![image-20210121201607225](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210121201607225.png)

> 我们为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。



一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。

> 我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引。其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认都是使用B+树索引，**统称索引**。当然除了B+树这种类型的索引之外，还有哈希索引(hash index)等

## 索引的优势

* 提高数据检索的效率，降低数据库IO成本
* 通过索引列对数据进行排序，降低数据排序成本，降低CPU的消耗

## 索引的劣势

1. 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引也要**占用空间**
2. 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行`INSERT`、`UPDATE`和`DELETE`。因为更新表时MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
3. 索引只是提高效率的一种因素，如果你的MySQL有大量数据表，就需要花时间研究建立最优秀的索引，或优化查询

## MySQL索引分类

* 单值索引： 即一个索引只包含单个列，一个表可以有多个单列索引
* 唯一索引： 即索引列的值必须唯一，但允许有空值
* 复合索引： 即一个索引包含多个列
* 全文索引: 用来做全文查询
* 主键索引: 主键和记录构成的索引

## 索引语法

创建

```sql
CREATE [UNIQUE] INDEX <index_name> ON <table_name> (<column list>)
ALTER <table_name> ADD [UNIQUE] INDEX <index_name> on (<column list>)
```

删除

```sql
DROP INDEX <index_name> ON <table_name>
```

查看

```sql
SHOW INDEX FROM <table_name> \G
```

使用`ALTER`创建索引

```sql
ALTER TABLE <tab_name> ADD PRIMARY KEY (column_list)
```

> 该语句添加一个主键，这意味着索引值必须唯一的，且不能为NULL

```sql
ALTER TABLE <table_name> ADD UNIQUE <index_name>(column_list)
```

> 这条语句创建索引的值是唯一的(除了NULL外， NULL可能会出现多次)

```sql
ALTER TABLE <table_name> ADD INDEX <index_name>(column_list)
```

> 添加普通索引，索引值可出现多次

```sql
ALTER TABLE <table_name> ADD FULLTEXT <index_name>(column_list)
```

> 该语句指定了索引为FULLTEXT，用于全文索引

## MySQL索引结构

MySQL的索引有以下类型：

* BTree 索引
* Hash 索引
* Full-Text 全文索引
* R-Tree 索引

B+ 树索引介绍

![image-20210122143109841](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210122143109841.png)

> 索引原理
>
> [初始化介绍]
>
> 一颗 b+树，浅绿色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项(深蓝色)和指针黄色，如磁盘块1包含数据项17和35，包含指针P1、P2、P3。P1 表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。
>
> **真实数据存在与叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99**
>
> **非叶子节点不存储真实数据，只存储指引搜索方向的数据项**,如17、35并不真实存在于数据表中
>
> [查找过程]
>
> 如果要查找数据项29，那么首先会把磁盘块1有磁盘加载到内存，此时发生一次IO，在内存中用二分查找法确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短(相比磁盘的IO)可以忽略不计，通过磁盘块1的P2指针的磁盘位置把磁盘块3由磁盘加载到内存，发生两次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载到磁盘块8到内存，发生第三次IO，同时内存中左二分查找找到29，结束查询，总计三次IO。
>
> 真实情况是，3层b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提升将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

## 哪些情况需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段，外键关系建立索引
4. 频繁更新的字段不适合建立索引：因为每次更新不单单是更新了记录还会更新索引
5. Where条件里面用不到的字段不创建索引
6. 单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)
7. 查询中排序的字段，**排序字段若通过索引去访问将大大提高排序速度**
8. 查询中统计或者分组字段

## 哪些情况不需要创建索引

1. 表记录太少
2. 经常增删改的表

> Why: 虽然提高了查询速度，同时却降低更新表的速度，如对表进行INSERT、UPDATE、和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存以下索引文件。

3. 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，**如果某个数据列包含许多重复内容，为它建立索引就没有太大的实际效果**。

> 假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。
>
> 索引的选择性说指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是`1980/2000=0.99`。一个索引的选择性越接近于1，这个索引的效率越高。

## 参考资料

1. [MySQL · 引擎特性 · 二级索引分析](http://mysql.taobao.org/monthly/2020/01/01/)