## 表锁(偏读)

表锁偏向MyISAM存储引擎,开销小,加锁快;无死锁;锁定粒度大,发生锁冲突的概率最高,并发度最低.

**每个连接同时只能拥有1个锁,当申请新锁时,旧锁会被自动释放(读锁更新成写锁也是同样的情况)**, 当一个表发生锁竞争时,读锁不会阻塞读锁,写锁会阻塞任何锁,如下表格所述

| 锁类型 | 读锁 | 写锁 |
| ------ | ---- | ---- |
| 读锁   | √    | ×    |
| 写锁   | ×    | ×    |
|        |      |      |

### 案例分析

建表SQL

```sql
create table mylock(
    id int not null key  auto_increment,
    name varchar(20)
)engine myisam;

insert into mylock(name) values ('a'),('b'),('c'),('d'),('e');
```

加锁命令

```sql
lock table <表名> read; # 读锁
lock table <表名> write; # 写锁
lock table <表名> read, <表名>  write; # 或者合并在一起
```

解锁命令

```sql
unlock tables;
```

查看当前锁表情况

```sql
show open tables;
```

> <img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210127121220256.png" alt="image-20210127121220256" style="zoom:67%;" />
>
> <img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210127121309818.png" alt="image-20210127121309818" style="zoom:67%;" />

查看锁竞争情况

```sql
show status like 'table%';
```

> ![image-20210127124113924](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210127124113924.png)

读锁总结

>  假定`session-1`对某表上读锁后:

1. `session-1`只能查询被锁定的表,其他表的任何操作都不能进行,也不能修改被锁定的表的数据
2. 其他`session`, 除了不能修改被锁定的表,其他操作均可以进行, 当其他`session`修改被锁定的表时,**会被阻塞,直至解锁**.

写锁总结:

>  假定`session-1`对某表上写锁后:

1. `session-1`可以对上锁的表进行**任何操作**,不能对其他表进行任何操作
2. 其他`session`可以对其他未上锁的表进行任何操作,但不能对已经上锁的表进行任何操作,否则**会被阻塞**

从此可得,**`MyISAM`的读写锁调度是写优先,这也是MyISAM不适合左写为主表的引擎.因为写锁后,其他线程不能做任何操作,大量更新会使查询很难得到锁,从而造成永远阻塞**

## 行锁(偏写)

偏向`InnoDB`存储引擎,开销大,加锁慢;会出现死锁;锁定力度小,发生锁冲突的概率低,并发度也最高.

> `InnoDB`与`MyISAM`最大的不同点:一支持事务、二是采用了行级锁
>
> 事务知识回顾:
>
> 具体细节参考:[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)
>
> 事务是由一组SQL组成的逻辑处理单元,事务具有以下4个属性,通常称为ACID属性:
>
> * 原子性(Atomicity): 事务是一个原子操作单元,其对数据的修改,要么都执行,要么都不执行
> * 一致性(Consisten): 事务开始和完成时,数据都必须保持一致.这意味着所有相关的规则都必须应用于事务的修改,以保持数据的完整性;事务结束时,所有的内部数据结构(如B树索引或双向链表)也都必须正确.
> * 隔离性(Isolation): 数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的"独立"环境执行.这意味着事务处理过程中中间对外状态对外部不可见的,反之亦然
> * 持久性(Durable): 事务完成之后,他对于数据库的修改是永久性的,即使出现系统故障也能够保持.
>
> 并发事务处理带来的问题:
>
> * 更新丢失(Lost Update): 
>
> > 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问 题---最后的更新覆盖了由其他事务所做的更新 .
> >
> > 例如，两个程序员修改同一java文件每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改. 
> >
> > 如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题 
>
> * 脏读(Dirty Reads):
>
> > 一个事务正在对一条记录做修改 ,在这个事务完成并提交前,这条记录的数据就处于不一致状态;  这时另一个事务也读取这些"脏"数据,井据此做进一步的处理,  就全产生未提交的数据依赖关系。这种现象被形象地叫做"脏读".
> >
> >
> > 一句话事务A读取到了事务B**己修改但尚未提交的的数据**,还在这个数据基础上做了操作．此时如果B事务回滚,A读取 
> > 的致据无效,不符合一致性要求。 
>
> * 不可重复读(Non-Repeatable Reads):
>
> > 一个事务在读取某些数据后的某个时间,再次读取以前读过的数据,却发现其读出的数据已经发生了改变、或某些记录已经被删除了!这种现象就叫做"不可重复读"
> >
> > 一句话: 事务A读取到了事务B已经提交的修改数据,不符合隔离性.
>
> * 幻读(Phantom Reads):
>
> > 一个事务按照相同的查询条件重新读取以前检索过的数据,却发现其他事务插入了满足其查询条件的新数据,这种现象就称为"幻读"
> >
> > 一句话: 事务A读取到了事务B新提交的新增数据,不符合隔离性.(幻读和脏读有点类似,**脏读是事务B里面修改了数据,幻读是事务B里面新增了数据**)
>
> 在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。
>
> | **隔离级别**                 | **脏读（Dirty Read）** | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
> | ---------------------------- | ---------------------- | -------------------------------- | -------------------- |
> | 未提交读（Read uncommitted） | 可能                   | 可能                             | 可能                 |
> | 已提交读（Read committed）   | 不可能                 | 可能                             | 可能                 |
> | 可重复读（Repeatable read）  | 不可能                 | 不可能                           | 可能                 |
> | 可串行化（Serializable ）    | 不可能                 | 不可能                           | 不可能               |
>
>
>   * 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 
>   * 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 
>   * 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 
>   * 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞
>
> **InnoDB**引擎默认级别是可重复读,查看当前数据库的事务隔离级别: `show variables like 'tx_isolation'`



`InnoDB`是基于索引对行进行上锁的,**当没有索引可以上锁时(自动类型转换,或者根本没有索引),行锁会升级成表锁**.

### 间隙锁的危害

什么时间隙锁:

当我们用范围条件而不是相等条件检索数据,并请求排他锁或共享锁,`InnoDB`会给符合条件的已有数据的索引项加锁,对于建值条件范围内但不存在的记录,叫做"间隙(GAP)",`InnoDB`也会对这个间隙加锁,这种锁就是所谓的间隙锁(Next-Key锁);

> 例如已知表:
>
> <img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210127151118997.png" alt="image-20210127151118997" style="zoom:67%;" />
>
> 当执行时
>
> ```sql
> set autocommit=0;
> update test_innodb_lock set b='0629' where a > 1 and a<6;
> ```
>
> 另个终端执行
>
> ```sql
> insert into test_innodb_lock values(2, '2000');
> ```
>
> 由于 2 位于 1 和 6之间,只有上一个事务执行完成后,这条命令才会被执行.

间隙锁的危害:

因为`Query`执行过程中通过范围查找的话,它会锁定整个范围所有的键值,即使这个键值并不存在.间隙锁有一个比较致命的缺点,就是锁定某一个范围键值之后,即使某些不存在的键值也会无辜锁定,而造成锁定的时候无法插入锁定键值范围内的任何数据.在某些场景下这可能对性能造成很大的危害.



### 如何锁定某一行

![image-20210127151955400](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210127151955400.png)

`InnoDB`存储引擎由于实现了行级锁定,虽然在锁定机制实现方面所带来的性能损耗可能比表级锁定会更高一些,但是整体并发处理能力方面要优于`MyISAM`的表级锁定.当系统并发量较高时,`InnoDB`整体性能和`MyISAM`相比就会有比较明显的优势了.



但是`InnoDB`的行级锁定同样也有其脆弱的一面,当我们使用不当的时候,可能会让`InnoDB`的整体性能表现不仅不能比`MyISAM`高,甚至更差.

### 行锁分析

通过检查`innodb_row_lock`状态变量来分析系统上的行锁的争夺情况

```sql
show status like 'innodb_row_lock%'
```

![image-20210127153214826](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210127153214826.png)

各个变量解释

* `Innodb_row_lock_current_waits`:当前正在锁定的数量
* `Innodb_row_lock_time`: 从系统启动到现在锁定总时间长度
* `Innodb_row_lock_time_avg`: 每次等待所花费的平均时间
* `Innodb_row_lock_time_max`: 从系统启动到现在等待最长的一次所花的时间
* `Innodb_row_lock_waits`: 系统启动后到现在总共等待的次数.

> 比较重要的三个变量`Innodb_row_lock_time_avg`,`Innodb_row_lock_time`,`Innodb_row_lock_waits`尤其是等待次数很高,而且每次等待时常也不小时,我们就需要分析系统中为什么有如此多的等待,然后分析结果着手指定优化计划.

### 优化建议

* 尽可能让所有数据检索都通过索引来完成,避免无索引行锁升级为表锁
* 合理设计索引,尽量缩小锁的范围
* 尽可能较小检索条件,避免间隙锁
* 尽量控制事务大小,减少锁定资源量和时间长度
* 尽可能低级别事务隔离



## 页锁

开销和加锁时间介于表锁和行锁之间,会出现死锁;锁定粒度介于表锁和行锁之间,并发度一般.

> 了解一下即可