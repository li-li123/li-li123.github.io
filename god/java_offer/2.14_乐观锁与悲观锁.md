悲观锁，总是假设最坏的情况，即每次获取数据的时候都认为会被别人修改，所以在每次获取数据之前都会都数据加锁，获取完成之后再释放锁。悲观锁，将阻塞其他线程，所以效率较低。

乐观锁，总是假设最好的情况，即认为每次获取数据都不会有人修改，所以不使用锁，而是通过 CAS 算法的自旋方式实现，每次在更新的时候会判断下在此期间别人有没有更新这个数据。省去了锁的开销，效率更高，但是在写竞争压力大的时候讲有不断的自旋发生，消耗更多的 CPU 资源。

-------

因此，乐观锁适合写比较少的情况，即冲突少的情况下，省去了锁的开销，加大了系统的整个吞吐量。但是写竞争明显的情况，会导致乐观锁不断重试，消耗更多 CPU 资源，降低了性能，所以写竞争明显的情况下，使用悲观锁比较合适。