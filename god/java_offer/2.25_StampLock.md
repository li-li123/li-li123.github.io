`StampedLock` 类，在JDK1.8时引入，是对读写锁 `ReentrantReadWriteLock` 的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，更细粒度控制并发。
`StampedLock` 的主要特点概括一下，有以下几点：

1. 所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功；
2. 所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；
3. StampedLock是不可重入的（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）;
4. StampedLock有三种访问模式：
   1. Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似
   2. Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似
   3. Optimistic reading（乐观读模式）：这是一种优化的读模式

> 我们知道，在 `ReentrantReadWriteLock` 中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会阻塞。但是，在`Optimistic reading` 中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用 `Optimistic reading` 获取到读锁时，必须对获取结果进行校验。

5. StampedLock支持读锁和写锁的相互转换

> 我们知道 RRW 中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的。StampedLock 提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。

6. 无论写锁还是读锁，都不支持Conditon等待

```java
package Lock.AQS;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.StampedLock;

public class StampLockTest {

    public static void main(String[] args) throws InterruptedException {
        data data = new data(1);
        new Thread(() -> {
            try {
                data.read(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t1").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                data.read(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t2").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            data.write(10000);
        },"t2").start();

    }

}

class data{

    private int data;
    private final StampedLock stamplock = new StampedLock();

    public data(int data) {
        this.data = data;
    }

    public int read(int ReadTime) throws InterruptedException {
        long stamp = stamplock.tryOptimisticRead();
        System.out.println("乐观读锁加锁： =  " + stamp + "-------" + Thread.currentThread().getName());
        TimeUnit.SECONDS.sleep(ReadTime);
        if(stamplock.validate(stamp)){
            System.out.println("读完成： =  " + stamp + "-------" + Thread.currentThread().getName());
            return data;
        }
        System.out.println("准备读锁： =  " + stamp + "-------" + Thread.currentThread().getName());
        try {
            stamp = stamplock.readLock();
            System.out.println("读锁加锁： =  " + stamp + "-------" + Thread.currentThread().getName());
            TimeUnit.SECONDS.sleep(ReadTime);
            System.out.println("读完成： =  " + stamp + "-------" + Thread.currentThread().getName());
            return data;
        }
        finally {
            System.out.println("读锁解锁： =  " + stamp + "-------" + Thread.currentThread().getName());
            stamplock.unlockRead(stamp);
        }
    }

    public void write(int WriteTime){
        long stamp = stamplock.writeLock();
        System.out.println("写锁加锁： =  " + stamp + "-------" + Thread.currentThread().getName());
        try {
            TimeUnit.SECONDS.sleep(2);
            this.data = WriteTime;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("写锁解锁： =  " + stamp + "-------" + Thread.currentThread().getName());
            stamplock.unlockWrite(stamp);
        }
    }

}
```

