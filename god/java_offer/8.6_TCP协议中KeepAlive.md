首先介绍一下 HTTP 协议中 KeepAlive 与 TCP 中 KeepAlive 的区别：

* HTTP 协议(七层)的 KeepAlive 意图在于连接复用，希望可以短时间内在同一个连接上进行多次请求/响应。
* TCP 协议(四层)的 KeepAlive 机制意图在于保活、心跳，检测连接错误。当一个 TCP 连接两端长时间没有数据传输时(通常默认配置是 2 小时)，发送 KeepAlive 探针，探测链接是否存活。



回到 TCP KeepAlive 探针，对于一方发起的 KeepAlive 探针，另一方必须响应。响应可能是以下三种形式之一

1. 对方回应了 ACK。说明一切 OK。如果接下来 2 小时还没有数据传输，那么还会继续发送 KeepAlive 探针，以确保连接存活。

2. 对方回复 RST，表示这个连接已经不存在。例如一方服务宕机后重启，此时接收到探针，因为不存在对应的连接。

3. 没有回复。说明 Socket 已经被关闭了。

   

但是TCP的KeepAlive机制存在一些问题：

- KeepAlive 只能检测连接是否存活，不能检测连接是否可用，比如一端发生了死锁，无法在连接上进行任何读写操作，但是操作系统仍然可以响应网络层 KeepAlive 包。
- `TCP KeepAlive` 机制依赖于操作系统的实现,灵活性不够，默认关闭，且默认的 KeepAlive 心跳时间是 两个小时, 时间较长。 
- 代理(如 Socks Proxy )、或者负载均衡器，会让 TCP KeepAlive 失效