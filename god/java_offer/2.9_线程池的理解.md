## 线程池介绍

> 本文直接摘抄自美团技术文档-[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)

### 线程池是什么

线程池 (Thread Pool) 是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。

线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。

而本文描述线程池是JDK中提供的 `ThreadPoolExecutor` 类。

当然，使用线程池可以带来一系列好处：

- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池`ScheduledThreadPoolExecutor` ，就允许任务延期执行或定期执行。

### 线程池解决的问题是什么

线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：

1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。
2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。
3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。

为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。

>  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia

“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。

在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：

1. 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。
2. 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。
3. 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。

在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。

## 线程池核心设计与实现

在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。

### 总体设计

Java中的线程池核心实现类是 `ThreadPoolExecutor` ，本章基于JDK 1.8 的源码来分析 Java 线程池的核心设计与实现。我们首先来看一下 `ThreadPoolExecutor` 的UML类图，了解下 `ThreadPoolExecutor` 的继承关系。

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/ThreadPoolExecutor UML类图.png" alt="ThreadPoolExecutor UML类图"  /></center>

`ThreadPoolExecutor` 实现的顶层接口是 `Executor` ，顶层接口 `Executor` 提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供 `Runnable` 对象，将任务的运行逻辑提交到执行器(Executor)中，由 `Executor`  框架完成线程的调配和任务的执行部分。`ExecutorService`  接口增加了一些能力：

1. 扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；
2. 提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。

ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/ThreadPoolExecutor运行流程.png" alt="ThreadPoolExecutor运行流程"  /></center>

线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：

* 直接申请线程执行该任务；
* 缓冲到队列中等待线程执行；
* 拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

接下来，我们会按照以下三个部分去详细讲解线程池运行机制：

1. 线程池如何维护自身状态。
2. 线程池如何管理任务。
3. 线程池如何管理线程。

### 生命周期管理

线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态( `runState`  )和线程数量 ( `workerCount` )。在具体实现中，线程池将运行状态( `runState` )、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```

`ctl` 这个 `AtomicInteger`  类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 ( `runState` ) 和线程池内有效线程的数量 ( `workerCount` )，高3位保存 `runState` ，低29位保存`workerCount` ，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。

关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：

```java
private static int runStateOf(int c)     { return c & ~CAPACITY; } //计算当前运行状态
private static int workerCountOf(int c)  { return c & CAPACITY; }  //计算当前线程数量
private static int ctlOf(int rs, int wc) { return rs | wc; }   //通过状态和线程数生成ctl
```

ThreadPoolExecutor的运行状态有5种，分别为：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/线程池运行状态.png" alt="线程池运行状态"  /></center>

其生命周期转换如下入所示：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/线程池生命周期.png" alt="线程池生命周期"  /></center>

### 任务执行机制

任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。

首先，所有任务的调度都是由 `execute` 方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：

* 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。
* 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。
* 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
* 如果 `workerCount >= corePoolSize && workerCount < maximumPoolSize` ，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
* 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

其执行流程如下图所示：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/任务调度流程.png" alt="任务调度流程"  /></center>

####  任务缓冲

任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。

阻塞队列( `BlockingQueue` )是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/阻塞队列.png" alt="阻塞队列"  /></center>

使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：

| 名称                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `ArrayBlockingQueue`    | 一个用数组实现的有界阻塞队列, 此队列按照先进先出(FIFO)       |
| `LinkedBlockingQueue`   | 一个由链表组成的有界队列,此队列按照先进先出(FIFO)的原则对元素进行排序,此队列的默认长度为`Integer.MAX_VALUE`. 所以默认创建的该队列有容量危险 |
| `LinkedBlockingDeque`   | 一个由链表结构组成的双向阻塞队列. 队列头部和尾部都可以添加和移除元素. 多线程并发时,可以将锁的竞争最多降到一半 (有界队列, 默认最大值 `Integer.MAX_VALUE` ) |
| `LinkedTransferQueue`   | 一个由链表结构组成的无界阻塞队列, 相当于其他队列,  `LinkedTransferQueue` 队列多了 `transfer` 和 `tryTransfer` 方法 |
| `PriorityBlockingQueue` | 一个支持线程优先级排序的无界队列, 默认自然序进行排列,也可以自定义实现 `compareTo()` 方法指定元素排序规则, 不能同时保证同优先级元素的顺序 |
| `DelayQueue`            | 一个基于 `PriorityBlockingQueue` 实现的无界队列, 在创建元素时, 可以指定多久才能从队中获取当前元素. 只有延时期满后,才能从队列中获取元素. |
| `SynchronousQueue`      | 一个不存储元素的阻塞队列, 每一 `put` 操作必须等待 `take` 操作, 否则不能添加元素. 支持公平锁和非公平锁. `SynchrouousQueue` 的一个使用场景是在线程池里. `Executors.newCachedThreadPool()`就使用了 `SynchronousQueue`. 这个线程根据需要(新任务到来时) 创建新线程, 如果有空闲线程就会重复使用, 线程空闲了 60 秒就会被回收. |

#### 任务申请

由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。

线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/获取任务流程图.png" alt="获取任务流程图" style="zoom:80%;" /></center>

getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。

#### 任务拒绝

任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。

拒绝策略是一个接口，其设计如下：

```java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：

| 名称                                   | 描述                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `ThreadExecutor.AborPolicy`            | 丢弃任务并抛出 `RejectedExecutionException` 异常. **这是线程池默认拒绝策略**, 在任务不能的时候抛出异常. 及时反馈程序运行状态.如果比较关键的业务, 推荐使用该拒绝策略, 这样子系统不饿能承载更大并发量的时候,能够及时的通过异常发现 |
| `TreadExecutor.DiscardPolicy`          | 丢弃任务,但是不抛异常. 使用此策略,可能会使我们无法发现系统的异常状态. 建议是一般无关紧要的业务采用此策略 |
| `ThreadPoolExecutor.DiscardOldesPlicy` | 丢弃队列最前面的任务, 然后重新提交被拒绝的任务. 是否要采用此策略,还得根据实际任务来认证衡量. |
| `ThreadPoolExecutor.CallerRunsPolicy`  | 由调用线程(提交任务的线程)处理该任务. 这种任务让所有任务都执行完毕. 那么就适合大量计算任务类型去执行, 多线程仅仅是增大吞吐量的手段,最终必须要让每个任务都执行完毕 |

### Worker线程管理

#### Worker线程

线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    final Thread thread;//Worker持有的线程
    Runnable firstTask;//初始化的任务，可以为null
}
```

Worker这个工作线程，实现了 `Runnable` 接口，并持有一个线程 `thread` ，一个初始化的任务 `firstTask` 。`thread` 是在调用构造方法时通过 `ThreadFactory` 来创建的线程，可以用来执行任务；`firstTask` 用它来保存传入的第一个任务，这个任务可以有也可以为 null 。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是 null，那么就需要创建一个线程去执行任务列表（`workQueue`）中的任务，也就是非核心线程的创建。

Worker执行任务的模型如下图所示：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/Worker执行任务.png" alt="Worker执行任务"  /></center>

线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张 Hash 表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。

Worker 是通过继承 AQS，使用 AQS 来实现独占锁这个功能。没有使用可重入锁 ReentrantLock ，而是使用 AQS ，为的就是实现不可重入的特性去反应线程现在的执行状态。

1. lock方法一旦获取了独占锁，表示当前线程正在执行任务中。

2. 如果正在执行任务，则不应该中断线程。 
3. 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 
4. 线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程，interruptIdleWorkers方法会使用 tryLock 方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。

在线程回收过程中就使用到了这种特性，回收过程如下图所示：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/申请线程执行流程图.png" alt="申请线程执行流程图" style="zoom:80%;" /></center>

#### **Worker线程回收**

线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker 被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当 Worker 无法获取到任务，也就是获取的任务为空时，循环会结束，Worker 会主动消除自身在线程池内的引用。

```java
try {
  while (task != null || (task = getTask()) != null) {
    //执行任务
  }
} finally {
  processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己
}
```

线程回收的工作是在processWorkerExit方法完成的。

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/线程销毁流程.png" alt="线程销毁流程" style="zoom:100%;" /></center>

事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。

#### **Worker线程执行任务**

在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：

1. while循环不断地通过 getTask() 方法获取任务。 
2. getTask() 方法从阻塞队列中取任务。 
3. 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 
4. 执行任务。 
5. 如果getTask结果为null则跳出循环，执行 `processWorkerExit()`  方法，销毁线程。

执行流程如下图所示：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/执行任务流程.png" alt="执行任务流程"  /></center>



## 常见面试问题

### shutdown 和 shutdownNow的区别

`shutdown` 会中断所有没有执行任务的线程；

`shutdownNow` 会尝试停止正在运行或者正在暂停的线程。

### 对CompletionService的理解，或者与ExecutorService的区别

为了解决Future的get阻塞问题，CompletionService以异步方式一边submit提交执行任务，一边take获取已完成的任务结果。可以将执行任务和处理任务结果的程序分离开同时处理，提高效率。

`CompletionService` 接口提供五个方法：

* `Future<V> submit(Callable<V> task)` : 提交Callable类型的task；
* `Future<V> submit(Runnable task, V result)`: 提交Runnable类型的task；
* `Future<V> take() throws InterruptedException`: 获取并移除已完成状态的task，如果目前不存在这样的task，则等待；
* `Future<V> poll()`: 获取并移除已完成状态的task，如果目前不存在这样的task，返回null；
* `Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException`: 获取并移除已完成状态的task，如果在指定等待时间内不存在这样的task，返回null。

使用方法

```java
public class CompletionServiceTest {
    public static void main(String[] args) throws Exception {
        ExecutorService service = Executors.newFixedThreadPool(5);
        CompletionService<String> completionService = new ExecutorCompletionService<String>(service);
        for (int i = 0; i < 5; i++) {
            completionService.submit(new ReturnAfterSleepCallable(i));
        }
        System.out.println("after submit");
        for (int i = 0; i < 5; i++) {
            System.out.println("result: " + completionService.take().get()); // 这个方法是阻塞的
        }
        System.out.println("after get");
        service.shutdown();
    }

    private static class ReturnAfterSleepCallable implements Callable<String> {
        int sleep;

        public ReturnAfterSleepCallable(int sleep) {
            this.sleep = sleep;
        }

        @Override
        public String call() throws Exception {
            TimeUnit.SECONDS.sleep(sleep);
            return System.currentTimeMillis() + ",sleep=" + String.valueOf(sleep);
        }
    }
}
```

### JDK 提供的线程池

* `newFixedThreadPool(int nThreads)`

`corePoolSize == maxPoolSize` (固定线程数量），阻塞队列选择LinkedBlockingQueue,几乎无界的队列，所以maxPoolSize keepAliveTime都没有意义。

* `newSingleThreadExecutor()`

也是固定线程数量的线程池，与 newFixedThreadPool()相比，newSingleThreadExecutor 限制线程数量为 1，也就保证了全部任务都安装放入的顺序来进行执行。

* `newCachedThreadPool()`

corePoolSize=0，maxPoolSize=Integer.MAX_VALUE, keepalive=60s, 阻塞队列使用了SynchronousQueue.这个队列不存储计算任务，而是直接提交给线程进行计算，不保持任务。 

### 线程数的选择

> [2020-10-26：线程池的线程数怎么设置比较好？](https://cloud.tencent.com/developer/article/1730603)

基础回答：

* CPU 密集型：【cpu核心数】【cpu核心数+1】【cpu核心数-1】。
* IO 密集型：【cpu核心数*2】。
* 混合型：【cpu核心数 / (1 - 阻塞系数)】，阻塞系数=阻塞时间/(阻塞时间+计算时间)。
* 求并发：【并发数=线程数/单个任务时间】。

中级回答

首先，考虑线程池究竟需要几个呢？不同业务是否需要不同线程池来避免某个业务阻塞时，其他业务也无法运行。最好是业务分类，不同的线程池去执行。

N-1原因：然后，每个线程池的线程数量，要考虑业务上下游，cpu，io 资源使用的情况，来设计。很多线程池设计为 cpu 核数-1，例如 Java 8 之后 jvm 启动时默认会启动的 coomonForkJoinPool，这个线程池执行 forkjointask，高峰时很容易吃满 cpu，属于计算密集型，这个情况下，最好设置为 cpu 核数 -1，避免出问题时吃满 cpu，导致其他业务完全无法运行，并且无法恢复以及定位问题。还有很多线程池设置为 cpu 核数 * 2，这是考虑 IO 是阻塞有延迟的，属于 IO 密集型，这样在 IO 阻塞，并且请求到达之间有延迟，每个线程都能充分运用。还要考虑业务上下游，例如上游业务线程池个数，下游业务线程池个数，还有 就是本身能使用的 IO 资源，例如数据库连接个数等等。

N+1 原因：计算密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下 CPU 周期不会中断工作。所以 N+1 确实是一个经验值。