## AQS 背景介绍

> 参考 
> 1.  [《The java.util.concurrent Synchronizer Framework》 JUC同步器框架（AQS框架）原文翻译](https://www.cnblogs.com/dennyzhangdd/p/7218510.html)
> 2.  [Java并发锁框架AQS(AbstractQueuedSynchronizer)原理从理论到源码透彻解析](https://www.bilibili.com/video/BV1yJ411v7er?spm_id_from=pageDriver)
> 3.  [不可不说的Java“锁”事](https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect)
> 4.  [从ReentrantLock的实现看AQS的原理及应用](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)


通过JCP的JSR166规范，Java的1.5版本引入了j.u.c包，这个包提供了一系列支持中等程度并发的类。这些组件是一系列的同步器（抽象数据类型(ADT)）。这些同步器主要维护着以下几个功能：内部同步状态的管理(例如：表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等。

几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性，开销，不灵活使其至多只能是个二流工程。且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。取而代之，JSR166建立了一个小框架，AQS类。这个框架为构造同步器提供一种通用的机制，并且被 j.u.c 包中大部分类使用，同时很多用户也用它来定义自己的同步器。

### AQS 功能需求

同步器一般包含两种方法，一种是 `acquire` ，另一种是 `release` 。`acquire` 操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而 `release` 操作则是通过某种方式改变同步状态，使得一或多个被 `acquire` 阻塞的线程继续执行。



j.u.c 包中并没有对同步器的 API 做一个统一的定义。因此，有一些类定义了通用的接口（如Lock），而另外一些则定义了其专有的版本。因此在不同的类中，`acquire` 和 `release` 操作的名字和形式会各有不同。例如：`Lock.lock`，`Semaphore.acquire`，`CountDownLatch.await` 和  `FutureTask.get` ，在这个框架里，这些方法都是 `acquire` 操作。但是，`J.U.C` 为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：

- 阻塞和非阻塞（例如 `tryLock` ）同步。
- 可选的超时设置，让调用者可以放弃等待
- 通过中断实现的任务取消，通常是分为两个版本，一个 `acquire` 可取消，而另一个不可以。



同步器的实现根据其状态是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。

j.u.c 包里还定义了 `Condition` 接口，用于支持监控形式的 `await/signal` 操作，这些操作与独占模式的 `Lock` 类有关，且Condition的实现天生就和与其关联的Lock类紧密相关。



### AQS 性能需求

Java内置锁（使用synchronized的方法或代码块）的性能问题一直以来都在被人们关注，并且已经有一系列的文章描述其构造）。 然而，大部分的研究主要关注的是在单核处理器上大部分时候使用于单线程上下文环境中时，如何尽量降低其空间（因为任何的Java对象都可以当成是锁）和时间的开销。对于同步器来说这些都不是特别重要：程序员仅在需要的时候才会使用同步器，因此并不需要压缩空间来避免浪费，并且同步器几乎是专门用在多线程设计中（特别是在多核处理器上），在这种环境下，偶尔的竞争是在意料之中的。因此，常规的JVM锁优化策略主要是针对零竞争的场景，而其它场景则使用缺乏可预见性的“慢速路径（slow paths）” ，所以常规的JVM锁优化策略并不适用于严重依赖于J.U.C包的典型多线程服务端应用。

> 现存的同步器性能太差, 或者不是很灵活



这里主要的性能目标是**可伸缩性**，即在大部分情况下，即使，或特别在同步器有竞争的情况下，稳定地保证其效率。在理想的情况下，不管有多少线程正试图通过同步点，通过同步点的开销都应该是个常量。在某一线程被允许通过同步点但还没有通过的情况下，使其耗费的总时间最少，这是主要目标之一。然而，这也必须考虑平衡各种资源，包括总CPU时间的需求，内存负载以及线程调度的开销。例如：获取自旋锁通常比阻塞锁所需的时间更短，但是通常也会浪费CPU时钟周期，并且造成内存竞争，所以使用的并不频繁。

实现同步器的这些目标包含了两种不同的使用类型。大部分应用程序是最大化其总的吞吐量，容错性，并且最好保证尽量减少饥饿的情况。然而，对于那些控制资源分配的程序来说，更重要是去维持多线程读取的公平性，可以接受较差的总吞吐量。没有任何框架可以代表用户去决定应该选择哪一个方式，因此，应该提供不同的公平策略。

> 上述句的意思是： 同步器应该提供公平模式和非公平模式(高吞吐量)

## AQS 核心概念及使用说明

全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架
特点：

* 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁
  * getState - 获取 state 状态
  * setState - 设置 state 状态
  * compareAndSetState - cas 机制设置 state 状态
  * 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源
* 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList
* 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet

子类主要实现这样一些方法（默认抛出 `UnsupportedOperationException` ）

* `tryAcquire`
* `tryRelease`
* `tryAcquireShared`
* `tryReleaseShared`
* `isHeldExclusively`



## AQS 使用示例

### JUC 实现类锁

```java
class Mutex implements Lock, java.io.Serializable {

   // 内部帮助类
   private static class Sync extends AbstractQueuedSynchronizer {
     // 判断是否持有锁
     protected boolean isHeldExclusively() {
       return getState() == 1;
     }

     // 尝试加锁
     public boolean tryAcquire(int acquires) {
       assert acquires == 1; // 不支持其他模式
       if (compareAndSetState(0, 1)) {
         setExclusiveOwnerThread(Thread.currentThread());
         return true;
       }
       return false;
     }

     // 释放锁
     protected boolean tryRelease(int releases) {
       assert releases == 1; // 不支持其他模式
       if (getState() == 0) throw new IllegalMonitorStateException();
       setExclusiveOwnerThread(null);
       setState(0);
       return true;
     }

     // 提供不同的等待队列
     Condition newCondition() { return new ConditionObject(); }

     // Deserializes properly
     private void readObject(ObjectInputStream s)
         throws IOException, ClassNotFoundException {
       s.defaultReadObject();
       setState(0); // reset to unlocked state
     }
   }
    
     // 内部状态类
   private final Sync sync = new Sync();

   public void lock()                { sync.acquire(1); }
   public boolean tryLock()          { return sync.tryAcquire(1); }
   public void unlock()              { sync.release(1); }
   public Condition newCondition()   { return sync.newCondition(); }
   public boolean isLocked()         { return sync.isHeldExclusively(); }
   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
   public void lockInterruptibly() throws InterruptedException {
     sync.acquireInterruptibly(1);
   }
   public boolean tryLock(long timeout, TimeUnit unit)
       throws InterruptedException {
     return sync.tryAcquireNanos(1, unit.toNanos(timeout));
   }
 }
```

## AQS 原理说明

### 同步队列





### 独占锁

#### acquire 操作

1. 申请锁, 申请成功返回, 不成功跳转2
2. 判断等待队列是否为空, 如果为空, 初始化头节点后, 新建节点, 加入队列中; 不为空跳转3
3. 新建节点, 加入队列中

#### release 操作

1. 检查当前线程是否持有锁的线程是同一个线程
2. 修改锁的状态, state 字段
3. 唤醒队列中下一个节点的线程, 唤醒动作分两步
   1. 像自己的 `waitStatus` 设成 0
   2. 真正叫起线程



下一个节点被唤醒的操作如下

1. 检查自己的前驱是不是头节点
2. 争用锁, 争用锁不成功, 会继续挂起

### 共享锁

#### acquire 操作

1. 共享锁可以被多个线程同时拿到, 具体同步器实现类,是否允许看每个同步器自己的实现
2. 节点的 waitStatus 设置为 SHARED
3. 只修改 state 字段, 不设置持有锁的线程

#### release 操作

1. 修改锁状态, 修改 state 字段
2. 唤醒队列中头节点的下一个节点的线程
   1. 唤醒动作如下
   2. 将自己的watistatus 设置成 0
   3. 真正叫起线程
3. 取当前被唤醒的下一个节点,  **如果下一个节点也是 SHARED 模式, 则直接唤醒**

### 条件队列

#### await 操作

1. 创建条件队列,必要的时候初始化条件队列 或者把自己加入到条件队列
2. 释放当前线程占有的锁, 执行 `AQS release` 操作

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210306113348879.png" alt="image-20210306113348879"  /></center>

#### signal 操作

1. 把条件等待队列中的 `firstWaiter` 加入等待队列
2. 把刚刚加入到同步队列的节点前驱的 waitStatus 设置成 -1



> 扩展阅读： 
>
> [逐行分析AQS源码(3)——共享锁的获取与释放 - SegmentFault 思否](https://segmentfault.com/a/1190000016447307)

