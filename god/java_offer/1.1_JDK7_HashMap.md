## 前言



HashMap底层存储原理详解: `HashMap`的内部存储方式在`JDK1.7`是使用**数组、链表**,  在`JDK1.8`之后使用**数组、链表、红黑树**。算法使用[哈希算法](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)。 美团写了一篇很好的文章[Java 8系列之重新认识HashMap](https://tech.meituan.com/2016/06/24/java-hashmap.html)

## HashMap

<img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/20171119123859600.png" alt="20171119123859600" style="zoom: 80%;" />

**JDK1.7** 使用数组的方式存储数据， 用链表解决哈希冲突。而且使用**头插法**。

> * 头插法：将新节点插入到链表头节点之后，最终链表节点顺序与插入节点顺序相反（这里头节点不存储具体值）
>
> <img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/0.jfif" alt="img" style="zoom:67%;" />
>
> - 尾插法：将新节点插入到链表尾节点之后，最终链表节点顺序与插入节点顺序一致。
>
> <img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/1111.png" style="zoom:67%;" />



### 常量解析

```java

// 默认初始容量
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

// 最大容量 1 << 30 = 1073741824
static final int MAXIMUM_CAPACITY = 1 << 30;

// 加载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;

// 空常量
static final Entry<?,?>[] EMPTY_TABLE = {};

// hashMap中的容量数组, 存储相同hashcode的Entry链表
transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;

// 当前容量
transient int size;

// 加载阈值, 下次需要扩容的容量
int threshold;

// 加载因子
final float loadFactor;

// 修改次数
transient int modCount;

// 触发hash种子重新生成的静态量
static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;
```



### 内部类

```java
static class Entry<K,V> implements Map.Entry<K,V> {
        final K key; // key
        V value; // value
        Entry<K,V> next; // 链表中的下一个元素
        int hash; // hash值

		// ... 构造方法, getter, setter省略
    }
```



### 构造函数

```java
/**
* 无参构造器
*/
public HashMap() {
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    // DEFAULT_INITIAL_CAPACITY: 存储数组初始容量, 默认值: 1>> 4 = 16位
    // DEFAULT_LOAD_FACTOR: 负载因子, 超过该因子开始扩容. 默认值: 0.75
}

/**
* 有参构造器, 自定义初始容量和加载因子
*/
public HashMap(int initialCapacity, float loadFactor) {
    // 参数范围验证
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
	
    // 初始化容量和加载因子
    this.loadFactor = loadFactor;
    threshold = initialCapacity;
    // 初始化函数, HashMap为空, LinkedHashMap中需要做一些初始化(初始化存储链表)
    init();
}

void init() {
}
```

### put 方法

```java
/**
* put 方法
**/
public V put(K key, V value) {
    // 判断存储数组是否为空, 初始化存储数组
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 判空
    if (key == null)
        return putForNullKey(value);
    // 计算hash值
    int hash = hash(key);
    
    // 计算该<K,V>应该放在存储数组中的哪个位置上
    int i = indexFor(hash, table.length);
    
    
    // 如果Key已经存在, 更新key的同时返回旧值
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            // 更新为新值
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this); // linkedhashmap 才会设计, hashmap中函数体为空
            // 返回旧值
            return oldValue;
        }
    }
    // 增加修改次数
    modCount++;
    
    // 添加元素
    addEntry(hash, key, value, i);
    return null;
}

/**
* 初始化存储数组
*/
private void inflateTable(int toSize) {
    // 寻找一个2的N次方, 刚好大于size.(假设该值是2^N, 那么该值满足 2^N >= size > 2^(N-1)), 具体实现细节, 看下面的参考链接
    // 这样做是为了算key的hash值
    int capacity = roundUpToPowerOf2(toSize);

    // 计算下次扩容阈值
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    // 初始化存储数组
    table = new Entry[capacity];
    // 初始化hash函数种子
    initHashSeedAsNeeded(capacity);
    
}

/**
* 添加元素
* @param hash - hash值
* @param key - key
* @param value - value
* @param bucketIndex - 应该放置在存储数组中的位置
*/
void addEntry(int hash, K key, V value, int bucketIndex) {
    
    // 判断是否需要扩容, 扩容后更正数组中的位置
    if ((size >= threshold) && (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    // 创建Entry对象, 并赋值到数组中
    createEntry(hash, key, value, bucketIndex);
}

/**
* 往数组中添加元素
* @param hash - hash值
* @param key - key
* @param value - value
* @param bucketIndex - 应该放置在存储数组中的位置
*/
void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex]; // 取出头节点
    table[bucketIndex] = new Entry<>(hash, key, value, e); // 把新Entry添加到链表头部, 并更新存储数组中的值
    size++; // 更改当前存储总数
}
```

> ```java
> private static int roundUpToPowerOf2(int number) {
>  // assert number >= 0 : "number must be non-negative";
>  return number >= MAXIMUM_CAPACITY
>      ? MAXIMUM_CAPACITY
>      : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;
> }
> ```
>
> [Integer.highestOneBit(int i)方法的作用与底层实现](https://juejin.cn/post/6844903927402479629)
>
> 同时 `number - 1`是为了应对数字刚好为2的幂次方时的情况

### 确定哈希桶数组索引位置

> **扩容后key分布的桶索引会修改, 所以扩容的时候有转换表的过程**

```java
/**
* 计算 该hash在哪个桶内
*/
static int indexFor(int h, int length) {
    // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
    // 求桶的代码, 就可以说明为什么hashmap容量需要是2的N次方
    return h & (length-1);
}


/*
* 计算对象的hash
*/
final int hash(Object k) {
    int h = hashSeed;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    // 不停的异或来尽量使hashcode 随机
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
```

### 存储空值

```java
private V putForNullKey(V value) {
    for (Entry<K,V> e = table[0]; e != null; e = e.next) {
        // 判断是否有null的key
        if (e.key == null) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(0, null, value, 0);
    return null;
}
```

> **空值的key,永远放置0的桶内**

### 扩容

扩容在添加元素时触发

```java
/**
* 添加元素
* @param hash - hash值
* @param key - key
* @param value - value
* @param bucketIndex - 应该放置在存储数组中的位置
*/
void addEntry(int hash, K key, V value, int bucketIndex) {
    
    // 判断是否需要扩容, 扩容后更正数组中的位置
    if ((size >= threshold) && (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    // 创建Entry对象, 并赋值到数组中
    createEntry(hash, key, value, bucketIndex);
}

```

> `threshold`的计算方法是: `table.length`* 加载因子(默认0.75)

扩容代码

```java
void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    // 数组容量超过最大容量, 无法扩容
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }

    Entry[] newTable = new Entry[newCapacity];
    // 把原本的元素,迁移到新的数组中
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table = newTable;
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}

/**
* 迁移元素
* @param newTable - 新表
* @param rehash - 重新hash
*/
void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    // 循环全部元素, 同时使用头插法转移到新表中
    for (Entry<K,V> e : table) {
        while(null != e) {
            // *****************  该过程是导致JDK7线程问题, 产生循环链表
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            // 使用头插法
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
            // *****************  **********************
        }
    }
}

/*
* 初始化hash种子 
*/
final boolean initHashSeedAsNeeded(int capacity) {
    boolean currentAltHashing = hashSeed != 0;
    boolean useAltHashing = sun.misc.VM.isBooted() &&
         // 当容量到达某个定值时,重新生成hash种子 默认值为Integer.MAX_VALUE
        (capacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD);
    boolean switching = currentAltHashing ^ useAltHashing;
    if (switching) {
        hashSeed = useAltHashing
            ? sun.misc.Hashing.randomHashSeed(this)
            : 0;
    }
    return switching;
}
```

> 循环链表问题详解: 
>
> 假设有两个线程(`Thread-1` 和`Thread-2`), 同时对线程进行扩容(**注意这里假设3 2 1节点, 在新表和旧表的索引是相同的,才会有可能发生循环链表的现象**)
>
> <img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210210152018824.png" alt="image-20210210152018824" style="zoom: 80%;" />
>
> 在一个什么巧合的时刻, `Thread-1`先行完成转移, **而`Thread-2`没有抢到CPU, 在转移3节点时被中断了 **
>
> <img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210210152431204.png" alt="image-20210210152431204" style="zoom:80%;" />
>
> 使用头插法后, `Thread-2`会把3节点的next指针执行1节点, 同时把3节点放到数组里面
>
> <img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210210152740695.png" alt="image-20210210152740695" style="zoom:80%;" />
>
> 这样就会发生循环链表

### get 方法

```java
public V get(Object key) {
    if (key == null)
        return getForNullKey();
    Entry<K,V> entry = getEntry(key);

    return null == entry ? null : entry.getValue();
}

/*
* 获取对象
*/ 
final Entry<K,V> getEntry(Object key) {
    if (size == 0) {
        return null;
    }

    // 计算hash桶的位置
    int hash = (key == null) ? 0 : hash(key);
    // 遍历该桶并返回值
    for (Entry<K,V> e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        if (e.hash == hash &&
            ((k = e.key) == key || (key != null && key.equals(k))))
            return e;
    }
    return null;
}
```

### modcount

```java
HashMap<Integer, Integer> map = new HashMap<>();
map.put(1, 1);
map.put(2, 2);
for (Integer element:map.keySet()){
    if(element == 1){
        map.remove(1);
    }
}
// Exception in thread "main" java.util.ConcurrentModificationException
//	at java.util.HashMap$HashIterator.nextEntry(HashMap.java:922)
//	at java.util.HashMap$KeyIterator.next(HashMap.java:956)
//	at TestHashMap.main(TestHashMap.java:17)
```

HashMap所有修改都会modcount的值, 当遍历对象时, 会检查modcount的值是否修改, 如果发生修改, 会报`ConcurrentModificationExeceptio`异常

```java
private abstract class HashIterator<E> implements Iterator<E> {
        Entry<K,V> next;        // next entry to return
        int expectedModCount;   // For fast-fail
        int index;              // current slot
        Entry<K,V> current;     // current entry

        HashIterator() {
            expectedModCount = modCount;
            if (size > 0) { // advance to first entry
                Entry[] t = table;
                while (index < t.length && (next = t[index++]) == null)
                    ;
            }
        }

        public final boolean hasNext() {
            return next != null;
        }

        final Entry<K,V> nextEntry() {
            // 判断是否修改
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            Entry<K,V> e = next;
            if (e == null)
                throw new NoSuchElementException();

            if ((next = e.next) == null) {
                Entry[] t = table;
                while (index < t.length && (next = t[index++]) == null)
                    ;
            }
            current = e;
            return e;
        }

        public void remove() {
            if (current == null)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            Object k = current.key;
            current = null;
            HashMap.this.removeEntryForKey(k);
            expectedModCount = modCount;
        }
    }
```

如何删除key?

```java
HashMap<Integer, Integer> map = new HashMap<>();
map.put(1, 1);
map.put(2, 2);
Iterator<Integer> iterator = map.keySet().iterator();
while (iterator.hasNext()){
    if(iterator.next() == 1){
        iterator.remove();
    }
}
```