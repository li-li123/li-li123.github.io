--------

> 本文直接摘抄自-[SpringBoot启动流程及其原理](https://www.cnblogs.com/theRhyme/p/11057233.html)

-------

## Spring 家族

* `Spring` ： `Spring` 框架就像一个家族，有众多衍生产品例如 `boot` 、 `security` 、`jpa` 等等；但他们的基础都是 `Spring`  的 `ioc` 和 `aop` ，`ioc` 提供了依赖注入的容器， `aop` 解决了面向切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能。
* `Spring MVC`: `Spring MVC` 提供了一种轻度耦合的方式来开发 web 应用；它是 `Spring` 的一个模块，是一个 web 框架；通过`DispatcherServlet` ,  `ModelAndView`  和  `View Resolver`，开发 web 应用变得很容易；解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。

* `Spring Boot` : `Spring boot` 实现了 `auto-configuration` **自动配置**（另外三大神器 actuator 监控，cli 命令行接口，starter 依赖），降低了项目搭建的复杂度。它主要是为了解决使用 `Spring` 框架需要进行大量的配置太麻烦的问题，所以它并不是用来替代 `Spring` 的解决方案，而是和 `Spring` 框架紧密结合用于提升 `Spring` 开发者体验的工具；同时它集成了大量常用的第三方库配置(例如 `Jackson`, `JDBC`, `Mongo`, `Redis`, `Mail` 等等)，`Spring Boot` 应用中这些第三方库几乎可以零配置的开箱即用(`out-of-the-box`)。

## Spring Boot启动原理及相关流程概览

Spring Boot 是基于 Spring 的新型的轻量级框架，最厉害的地方当属***自动配置。***那我们就可以根据启动流程和相关原理来看看，如何实现传奇的自动配置。

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/1158841-20190707171658626-1389392187.png" alt="1158841-20190707171658626-1389392187"  /></center>

## Spring Boot的启动类入口

用过 Spring Boot 的技术人员很显而易见的两者之间的差别就是视觉上很直观的：Spring Boot 有自己独立的启动类（独立程序）

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

从上面代码可以看出，`Annotation` 定义（ `@SpringBootApplication` ）和类定义（ `SpringApplication.run` ）最为耀眼，所以要揭开 `SpringBoot` 的神秘面纱，我们要从这两位开始就可以了。

### SpringBootApplication

```java
@Target(ElementType.TYPE) // 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明
@Retention(RetentionPolicy.RUNTIME) // 注解的生命周期，保留到class文件中（三个生命周期）
@Documented // 表明这个注解应该被javadoc记录
@Inherited // 子类可以继承该注解
@SpringBootConfiguration // 继承了Configuration，表示当前是注解类
@EnableAutoConfiguration // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助
@ComponentScan(excludeFilters = { // 扫描路径设置（具体使用待确认）
    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
		...
}　
```

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/1158841-20190709114128801-171612088.png" alt="1158841-20190709114128801-171612088"  /></center>

在其中比较重要的有三个注解，分别是：

　　1）`@SpringBootConfiguration`  // 继承了Configuration，表示当前是注解类

　　2）`@EnableAutoConfiguration`  // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助

　　3）`@ComponentScan(excludeFilters = { // 扫描路径设置（具体使用待确认）`

-----

`@EnableAutoConfiguration` 此注解顾名思义是可以自动配置，所以应该是springboot中最为重要的注解。

在 Spring 框架中就提供了各种以 `@Enable` 开头的注解，例如： `@EnableScheduling` 、`@EnableCaching`、`@EnableMBeanExport`等；` @EnableAutoConfiguration` 的理念和做事方式其实一脉相承简单概括一下就是，借助`@Import`的支持，收集和注册特定场景相关的 bean 定义。　　

- `@EnableScheduling` 是通过 `@Import` 将 Spring 调度框架相关的 `bean` 定义都加载到 IoC 容器【定时任务、时间调度任务】
- `@EnableMBeanExport` 是通过 `@Import` 将 `JMX` 相关的 bean 定义加载到 IoC 容器【监控JVM运行时状态】
- `@EnableAutoConfiguration` 也是借助 `@Import` 的帮助，将所有符合自动配置条件的 bean 定义加载到 IoC 容器。
- `@EnableAutoConfiguration` 作为一个复合 `Annotation` ,其自身定义关键信息如下：

```java
@SuppressWarnings("deprecation")
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage //【重点注解】
@Import(AutoConfigurationImportSelector.class) //【重点注解】
public @interface EnableAutoConfiguration {
...
}
```

其中最重要的两个注解已经标注

1. `@AutoConfigurationPackage` 重点注解
2. `@Import(AutoConfigurationImportSelector.class`当然还有其中比较重要的一个类就是：`AutoConfigurationImportSelector.class`

-------

`AutoConfigurationPackage`注解：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {
 
}
```

通过 `@Import(AutoConfigurationPackages.Registrar.class)`

```java
static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {
 
        @Override
        public void registerBeanDefinitions(AnnotationMetadata metadata,
                BeanDefinitionRegistry registry) {
            register(registry, new PackageImport(metadata).getPackageName());
        }
 
        ……
 
    }
```

它其实是注册了一个Bean的定义；

`new PackageImport(metadata).getPackageName()`，它其实返回了**当前主程序类的**同级以及子级的包组件（重点）；

（重点）那这总体就是注册当前主程序类的同级以及子级的包中的符合条件的`Bean`的定义？

-------

`Import(AutoConfigurationImportSelector.class)` 注解

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210322210228884.png" alt="image-20210322210228884"  /></center>

核心方法

```java
@Override
public String[] selectImports(AnnotationMetadata annotationMetadata) {
    if (!isEnabled(annotationMetadata)) {
        return NO_IMPORTS;
    }
    // 加载 META-INF/spring.factories 下的文件
    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
    // 加载类并返回
    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
}
```

### SpringApplication

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/1158841-20190716164535793-477823131.png" alt="1158841-20190716164535793-477823131"  /></center>

## SpringMVC处理请求的流程

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210323100311910.png" alt="image-20210323100311910"  /></center>

1. 用户发送请求至前端控制器 `DispatcherServlet`
2. `DispatcherServlet` 收到请求调用 `HandlerMapping` 处理器映射器。
3. 处理器映射器根据请求 url 找到具体的处理器，生成处理器对象 `Handler` 及处理器拦截器(如果有则生成)一并返回给`DispatcherServlet`。
4. `DispatcherServlet` 通过 `HandlerAdapter`（让Handler实现更加灵活）处理器适配器调用处理器
5. 执行处理器( `Controller` ，也叫后端控制器)。
6. `Controller` 执行完成返回 `ModelAndView`（连接业务逻辑层和展示层的桥梁，持有一个 `ModelMap` 对象和一个 `View` 对象）。
7. `HandlerAdapter` 将 `controller` 执行结果 `ModelAndView` 返回给 `DispatcherServlet`
8. `DispatcherServlet` 将 `ModelAndView` 传给 `ViewReslover` 视图解析器
9. `ViewReslover` 解析后返回具体 `View`
10. `DispatcherServlet` 对 `View` 进行渲染视图（将 `ModelMap` 模型数据填充至视图中）。
11. `DispatcherServlet` 响应用户