在这里，我们可以介绍下阻塞队列的成员, 使用不同的队列可以实现不一样的任务存取策略。

| 名称                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `ArrayBlockingQueue`    | 一个用数组实现的有界阻塞队列, 此队列按照先进先出(FIFO)       |
| `LinkedBlockingQueue`   | 一个由链表组成的有界队列,此队列按照先进先出(FIFO)的原则对元素进行排序,此队列的默认长度为`Integer.MAX_VALUE`. 所以默认创建的该队列有容量危险 |
| `LinkedBlockingDeque`   | 一个由链表结构组成的双向阻塞队列. 队列头部和尾部都可以添加和移除元素. 多线程并发时,可以将锁的竞争最多降到一半 (有界队列, 默认最大值 `Integer.MAX_VALUE` ) |
| `LinkedTransferQueue`   | 一个由链表结构组成的无界阻塞队列, 相当于其他队列,  `LinkedTransferQueue` 队列多了 `transfer` 和 `tryTransfer` 方法 |
| `PriorityBlockingQueue` | 一个支持线程优先级排序的无界队列, 默认自然序进行排列,也可以自定义实现 `compareTo()` 方法指定元素排序规则, 不能同时保证同优先级元素的顺序 |
| `DelayQueue`            | 一个基于 `PriorityBlockingQueue` 实现的无界队列, 在创建元素时, 可以指定多久才能从队中获取当前元素. 只有延时期满后,才能从队列中获取元素. |
| `SynchronousQueue`      | 一个不存储元素的阻塞队列, 每一 `put` 操作必须等待 `take` 操作, 否则不能添加元素. 支持公平锁和非公平锁. `SynchrouousQueue` 的一个使用场景是在线程池里. `Executors.newCachedThreadPool()`就使用了 `SynchronousQueue`. 这个线程根据需要(新任务到来时) 创建新线程, 如果有空闲线程就会重复使用, 线程空闲了 60 秒就会被回收. |



> 1. `transfer` 与 `tryTransfer` 的作用
>
> `transfer`: 
>
> 如果当前有消费者正在等待接收元素（消费者使用 `take()` 方法或带时间限制的 `poll()` 方法时），`transfer` 方法可以把生产者传入的元素立刻 `transfer（传输）` 给消费者。如果没有消费者在等待接收元素，`transfer` 方法会将元素存放在队列的 `tail` 节点，并等到该元素被消费者消费了才返回。`transfer` 方法的关键代码如下。
>
> ```java
> Node pred = tryAppend(s, haveData);
> return awaitMatch(s, pred, e, (how == TIMED), nanos);
> ```
>
> 第一行代码是试图把存放当前元素的s节点作为 `tail` 节点。第二行代码是让 CPU 自旋等待消费者消费元素。因为自旋会消耗 CPU，所以自旋一定的次数后使用 `Thread.yield()` 方法来暂停当前正在执行的线程，并执行其他线程。
>
> `tryTransfer`:
>
> `tryTransfer` 方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 `transfer` 方法的区别是 `tryTransfer` 方法无论消费者是否接收，方法立即返回，而 `transfer` 方法是必须等到消费者消费了才返回。
>
> 对于带有时间限制的 `tryTransfer(E e，long timeout，TimeUnit unit)`方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 `false`，如果在超时时间内消费了元素，则返回 `true`

