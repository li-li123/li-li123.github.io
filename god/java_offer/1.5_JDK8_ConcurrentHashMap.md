

> 数组 + 链表 + 红黑树
>
> **JDK 8**没有分段, 只有数组与`HashMap相同`

## 成员变量

```java
// 最大容量
private static final int MAXIMUM_CAPACITY = 1 << 30;

// 默认容量
private static final int DEFAULT_CAPACITY = 16;

// 最大数组长度
static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

// 竞争度, 没有使用. 为了兼容性保留
private static final int DEFAULT_CONCURRENCY_LEVEL = 16;

// 默认加载因子
private static final float LOAD_FACTOR = 0.75f;

// 树化的长度
static final int TREEIFY_THRESHOLD = 8;

// 解除树化的长度
static final int UNTREEIFY_THRESHOLD = 6;

// 最小触发树化的容量
static final int MIN_TREEIFY_CAPACITY = 64;

// 
private static final int MIN_TRANSFER_STRIDE = 16;

// 
private static int RESIZE_STAMP_BITS = 16;

// 
private static final int MAX_RESIZERS = (1 << (32 - RESIZE_STAMP_BITS)) - 1;

// 
private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;

// 哈希桶标志位
static final int MOVED     = -1; // hash for forwarding nodes, 正在扩容
static final int TREEBIN   = -2; // hash for roots of trees
static final int RESERVED  = -3; // hash for transient reservations
static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash

// 哈希桶
transient volatile Node<K,V>[] table;

// 下一要使用的表, 只在扩容时使用
private transient volatile Node<K,V>[] nextTable;

// 计算容量
private transient volatile long baseCount;

// 扩容阈值
private transient volatile int sizeCtl;

// 正在的转换的哈希桶索引
private transient volatile int transferIndex;

// 计数时, 正在计数的cell
private transient volatile int cellsBusy;

// 计数格, 用于size计数
private transient volatile CounterCell[] counterCells;
```



## 构造方法

```java
public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (initialCapacity < concurrencyLevel)   // Use at least as many bins
        // 初始化容量
        initialCapacity = concurrencyLevel;   // as estimated threads
    // 扩容的触发容量
    long size = (long)(1.0 + (long)initialCapacity / loadFactor);
    // 当前容量
    int cap = (size >= (long)MAXIMUM_CAPACITY) ?
        MAXIMUM_CAPACITY : tableSizeFor((int)size);
    
    this.sizeCtl = cap;
}
```



## put 方法

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode()); // 计算hash值
    int binCount = 0; // ?
    
    for (Node<K,V>[] tab = table;;) {
    
        Node<K,V> f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
        	// 初始化数组
            tab = initTable();
        
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { // 计算key放置的哈希桶是否为空
        
            if (casTabAt(tab, i, null,
                         new Node<K,V>(hash, key, value, null))) // 使用原子操作放置key
                // 放置成功, 函数返回
                break;                   // no lock when adding to empty bin
        }
          
        else if ((fh = f.hash) == MOVED) // 标志位表示, 当前map正在被一个或多个线程扩容
            tab = helpTransfer(tab, f); // 帮助扩容
        else {
            V oldVal = null;
             
            synchronized (f) {
                
                if (tabAt(tab, i) == f) { // 判断链表没有改变
                    
                    if (fh >= 0) { // 该哈希桶的存储结构是链表
                        binCount = 1; // 链表的长度
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                              value)) != null) {
                            // 红黑树
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            
            // 插入完成, 判断树化
            
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i); // 链表长度大于阈值, 开始树化
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount); // 容量 + 1 , 同时触发扩容
    return null;
}
```

## 树化

```java
private final void treeifyBin(Node<K,V>[] tab, int index) {
    Node<K,V> b; int n, sc;
    if (tab != null) {
        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)
            tryPresize(n << 1);
        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {
            synchronized (b) {
                if (tabAt(tab, index) == b) { // 对哈希桶的第一个元素加锁
                    TreeNode<K,V> hd = null, tl = null;
                    
                    // 遍历链表, 把链表节点转化位TreeNode
                    for (Node<K,V> e = b; e != null; e = e.next) {
                        TreeNode<K,V> p =
                            new TreeNode<K,V>(e.hash, e.key, e.val,
                                              null, null);
                        if ((p.prev = tl) == null)
                            hd = p;
                        else
                            tl.next = p;
                        tl = p;
                    }
                    
                    // 转化红黑树
                    setTabAt(tab, index, new TreeBin<K,V>(hd));
                }
            }
        }
    }
}

/**
* 直接生成红黑树
*/
TreeBin(TreeNode<K,V> b) {
    super(TREEBIN, null, null, null);
    this.first = b;
    TreeNode<K,V> r = null;
    
    for (TreeNode<K,V> x = b, next; x != null; x = next) {
        next = (TreeNode<K,V>)x.next;
        x.left = x.right = null;
        if (r == null) {
            x.parent = null;
            x.red = false;
            r = x;
        }
        else {
            K k = x.key;
            int h = x.hash;
            Class<?> kc = null;
            for (TreeNode<K,V> p = r;;) {
                int dir, ph;
                K pk = p.key;
                if ((ph = p.hash) > h)
                    dir = -1;
                else if (ph < h)
                    dir = 1;
                else if ((kc == null &&
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0)
                    dir = tieBreakOrder(k, pk);
                TreeNode<K,V> xp = p;
                if ((p = (dir <= 0) ? p.left : p.right) == null) {
                    x.parent = xp;
                    if (dir <= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    r = balanceInsertion(r, x);
                    break;
                }
            }
        }
    }
    this.root = r;
    assert checkInvariants(root);
}
```

> `ConcurrentHashMap`没有在哈希桶中直接存储`TreeNode`的愿意在于: 多线程并发时需要对红黑树的头节点加锁, 如果哈希桶直接存放`TreeNode`, 其他线程在操作红黑树时, 有可能调整头节点, 导致另外一个线程加的锁不是真正的头节点.
>
> 使用 `TreeBin` 后, 直接对 `TreeBin` 加锁, 这让其他线程在加锁后, 无法操作该红黑树

 ## 初始化

```java
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) { // 判断是否为空
        
        if ((sc = sizeCtl) < 0)
            Thread.yield(); // 有其他线程拿到了扩容权限, 暂时放弃线程调度
        
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { // 尝试修改标志位
            try {
                if ((tab = table) == null || tab.length == 0) { // 二次验证
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings("unchecked")
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2); // n - ( n * 0.75)
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
```

## 计数(触发扩容)

```java
/*
* 计数触发扩容
* @param: x 容量变化数值, put方法传值 1, remove 方法传值 -1
* @param: check 校验容量, put方法传参为正数, remove方法传参为负数
*/
private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    
    if ((as = counterCells) != null || // counterCell 不为空
!U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {  // 线程尝试用乐观锁,对BASECOUNT + 1
        // 乐观锁 + 1 失败
        
        CounterCell a; long v; int m;
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) < 0 ||
            (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
            !(uncontended =
              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            // counterCell 为空 或者 counterCell 不为空, 但是CAS + 1 失败
            
            fullAddCount(x, uncontended); // 最坏情况, 针对N种情况计数: 下面会进行详细解释
            
            
            return;
        }
        if (check <= 1) // 判断是否进行容量校验
            return;
        s = sumCount(); // 计数
    }
    
    // ============ 扩容代码 ===================
    if (check >= 0) { // 需要校验容量
        
        Node<K,V>[] tab, nt; int n, sc;
        while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
               (n = tab.length) < MAXIMUM_CAPACITY) { // 容量超过阈值, 且没有超过最大值
        
             // resizeStamp(n) 会返回一个数, 它左移 RESIZE_STAMP_SHIFT位, 一定是负数
            int rs = resizeStamp(n);
            
            if (sc < 0) { // 有线程正在扩容转移
                
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex <= 0) // 扩容结束
                    break;
                
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            
            }
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs << RESIZE_STAMP_SHIFT) + 2))
            	// 获得乐观锁的线程进行转移    
                transfer(tab, null);
            s = sumCount();
        }
    }
    
    //  扩容代码结束
}
```



<center>累加器实现</center>

<iframe id="iframe" src="https://book.ironblog.cn/code_html/jdk8_cmap_fullAddCount.html" width="100%" height="850" frameborder="no" border="0" style="border: none;display: block;margin: 0 auto;"></iframe>

> 解决冲突计数, 其实现方法类似于: `java.util.concurrent.atomic.LongAdder`



<center>转移方法</center>

<iframe id="iframe" src="https://book.ironblog.cn/code_html/jdk8_cmap_transfer.html" width="100%" height="850" frameborder="no" border="0" style="border: none;display: block;margin: 0 auto;"></iframe>



<center>帮助扩容</center>



```java
final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
    Node<K,V>[] nextTab; int sc;
    if (tab != null && (f instanceof ForwardingNode) &&
        (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
        int rs = resizeStamp(tab.length);
        while (nextTab == nextTable && table == tab &&
               (sc = sizeCtl) < 0) {
            if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || transferIndex <= 0)
                break;
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) { // 设置扩容标志位,标识扩容线程+1
                transfer(tab, nextTab);
                break;
            }
        }
        return nextTab;
    }
    return table;
}
```

