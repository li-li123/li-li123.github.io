> 本文转载至-[[深入剖析Java中的装箱和拆箱](https://www.cnblogs.com/dolphin0520/p/3780005.html)](https://www.cnblogs.com/dolphin0520/p/3780005.html)



## 什么是装箱？什么是拆箱？

在前面的文章中提到，Java为每种基本数据类型都提供了对应的包装器类型，至于为什么会为每种基本数据类型提供包装器类型在此不进行阐述，有兴趣的朋友可以查阅相关资料。在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：

```java
Integer i = new Integer(10);
```

而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：

```java
Integer i = 10;
```

这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：

```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

简单一点说，装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。下表是基本数据类型对应的包装器类型：

| 基础类型    | 包装类型   |
| --------------- | --------- |
| int（4字节）    | Integer   |
| byte（1字节）   | Byte      |
| short（2字节）  | Short     |
| long（8字节）   | Long      |
| float（4字节）  | Float     |
| double（8字节） | Double    |
| char（2字节）   | Character |
| boolean（未定） | Boolean   |

## 装箱和拆箱是如何实现的

上一小节了解装箱的基本概念之后，这一小节来了解一下装箱和拆箱是如何实现的。我们就以Interger类为例，下面看一段代码：

```java
public class Main {
    public static void main(String[] args) {
         
        Integer i = 10;
        int n = i;
    }
}
```

　反编译class文件之后得到如下内容：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/101641567956500.jpg" alt="101641567956500"  /></center>

从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。

其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。

因此可以用一句话总结装箱和拆箱的实现过程：

装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。

### 面试常见问题

1. 下面这段代码的输出结果是什么？

   ```java
   public class Main {
       public static void main(String[] args) {
            
           Integer i1 = 100;
           Integer i2 = 100;
           Integer i3 = 200;
           Integer i4 = 200;
            
           System.out.println(i1==i2); // true
           System.out.println(i3==i4); // false
       }
   }
   ```

   > `Integer`  会缓存 -127~  127 之间的数, 同理还有 `Boolean` , `Character`(缓存 0 ~ 127)

2. 下面这段代码的输出结果是什么？

```java
public class Main {
    public static void main(String[] args) {
         
        Double i1 = 100.0;
        Double i2 = 100.0;
        Double i3 = 200.0;
        Double i4 = 200.0;
         
        System.out.println(i1==i2); // false
        System.out.println(i3==i4); // false
    }
}
```

> double 不缓存 

3. 下面这段代码输出结果是什么：

```java
public class Main {
    public static void main(String[] args) {
         
        Boolean i1 = false;
        Boolean i2 = false;
        Boolean i3 = true;
        Boolean i4 = true;
         
        System.out.println(i1==i2);
        System.out.println(i3==i4);
    }
}
```

> Boolean 缓存

4. 下面程序的输出结果是什么？

```java
public class Main {
    public static void main(String[] args) {
         
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Integer d = 3;
        Integer e = 321;
        Integer f = 321;
        Long g = 3L;
        Long h = 2L;
         
        System.out.println(c==d);
        System.out.println(e==f);
        System.out.println(c==(a+b));
        System.out.println(c.equals(a+b));
        System.out.println(g==(a+b));
        System.out.println(g.equals(a+b));
        System.out.println(g.equals(a+h));
    }
}
```

先别看输出结果，读者自己想一下这段代码的输出结果是什么。这里面需要注意的是：**当 "=="运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）**。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然：