## Spring 事务注解解析

```java
public @interface Transactional {

	/**
	 * 事务管理器
	 */
	@AliasFor("transactionManager")
	String value() default "";

	/**
	 * 事务管理器
	 */
	@AliasFor("value")
	String transactionManager() default "";

	/**
	 * 事务传播机制
     */
	Propagation propagation() default Propagation.REQUIRED;

	/**
	 * 隔离级别, 默认采用数据库的隔离级别
	 */
	Isolation isolation() default Isolation.DEFAULT;

	/**
	 * 事务超时时间: 默认采用数据库默认的事务超时时间
	 */ 
	int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;

	/**
	 *  该操作是否只读取数据库
	 */
	boolean readOnly() default false;

	/**
	 * 回滚的类
	 */
	Class<? extends Throwable>[] rollbackFor() default {};

	/*
	* 回滚的类名
	*/
	String[] rollbackForClassName() default {};

	/*
	* 不回滚的类
	*/
	Class<? extends Throwable>[] noRollbackFor() default {};

	/*
	* 不回滚的类名
	*/
	String[] noRollbackForClassName() default {};

}
```



## Spring 事务的传播机制

##### PROPAGATION_REQUIRED (默认)

- 支持当前事务，如果当前没有事务，则新建事务
- 如果当前存在事务，则加入当前事务，合并成一个事务

#### REQUIRES_NEW

- 新建事务，如果当前存在事务，则把当前事务挂起
- 这个方法会独立提交事务，不受调用者的事务影响，父级异常，它也是正常提交

#### NESTED

- 如果当前存在事务，它将会成为父级事务的一个子事务，方法结束后并没有提交，只有等父事务结束才提交
- 如果当前没有事务，则新建事务
- 如果它异常，父级可以捕获它的异常而不进行回滚，正常提交
- 但如果父级异常，它必然回滚，这就是和 `REQUIRES_NEW` 的区别

#### SUPPORTS

- 如果当前存在事务，则加入事务
- 如果当前不存在事务，则以非事务方式运行，这个和不写没区别

#### NOT_SUPPORTED

- 以非事务方式运行
- 如果当前存在事务，则把当前事务挂起

#### MANDATORY

- 如果当前存在事务，则运行在当前事务中
- 如果当前无事务，则抛出异常，也即父级方法必须有事务

#### NEVER

- 以非事务方式运行，如果当前存在事务，则抛出异常，即父级方法必须无事务

#### 一点小说明

一般用得比较多的是 `PROPAGATION_REQUIRED `， `REQUIRES_NEW`；

`REQUIRES_NEW` 一般用在子方法需要单独事务，暂时找不到例子，以后补充 。