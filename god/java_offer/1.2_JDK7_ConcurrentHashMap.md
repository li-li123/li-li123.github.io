



<img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210210163837342.png" alt="image-20210210163837342"  />

为了解决并发的问题, `ConcurrentHashMap`分成多个区域, 每个区域持有多个实际的`KV`键值对.  当并发访问时对`Segment`进行上锁

## 常量解析

```java
// 容量
static final int DEFAULT_INITIAL_CAPACITY = 16;

//  加载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;

// 并发级别(segment的个数)
static final int DEFAULT_CONCURRENCY_LEVEL = 16;

// 最大容量
static final int MAXIMUM_CAPACITY = 1 << 30;

// 每个分段的最小容量
static final int MIN_SEGMENT_TABLE_CAPACITY = 2;

// 最多的分片数
static final int MAX_SEGMENTS = 1 << 16; // slightly conservative

// 锁的重试次数
static final int RETRIES_BEFORE_LOCK = 2;
```

## 构造方法

```java
/*
* 默认构造器
*/
public ConcurrentHashMap() {
	// 设置默认容量, 加载因子, 并发度
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
}

/*
* 全参构造器
* 
* @param initialCapacity - 容量
* @param loadFactor - 加载因子
* @param concurrencyLevel - 并发度(segment的长度)
*/
public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    // 值检查
    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel > MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    
    // 计算segment的大小, 第一个大于等于并发级别的2的幂次方数
    int sshift = 0; // segment移动位数
    int ssize = 1;  // segment数组大小
    while (ssize < concurrencyLevel) {
        ++sshift;
        ssize <<= 1;
    }
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1; // 计算segment桶的掩码
    // 计算结束
    
    
    // 计算每个segment应该放的元素个数
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
        ++c;
    
    // 修正segment存放的元素个数, 让其满足大于等于最小容量(每个hashEntry的大小必须是2的幂次方)
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap < c)
        cap <<= 1;
    // 计算结束
    
    
    // 初始化 segment
    Segment<K,V> s0 =
        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
                         (HashEntry<K,V>[])new HashEntry[cap]);
    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];
    
    // 把segment放置到 segment数组的第一位(之后生成的segment对象, 以这个segment为模板生成)
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
```

> 1. **`ConcurrentHashMap`的扩容只跟Segment有关**
>
> 2. 使用UNSAFE操作数组的原因是: **Unsafe直接操作堆内存, 保证线程安全**

## put 方法

```java
public V put(K key, V value) {
    Segment<K,V> s;
    // 判空
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    // 计算该 key 应该放在哪个segment中
    int j = (hash >>> segmentShift) & segmentMask;
    
    // 取segment数组的第j个位置, 如果为空, 初始化新的segment对象
    if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);
    // 调用segment内部实现进行put
    return s.put(key, hash, value, false);
}

/**
* 初始化segment对象
* @param k segment数组下标
*/
private Segment<K,V> ensureSegment(int k) {
    final Segment<K,V>[] ss = this.segments;
    long u = (k << SSHIFT) + SBASE; // raw offset
    Segment<K,V> seg;
    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {
        // 以 segemnt[0] 为原型初始化segment对象
        Segment<K,V> proto = ss[0]; // use segment 0 as prototype
        int cap = proto.table.length;
        float lf = proto.loadFactor;
        int threshold = (int)(cap * lf);
        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];
        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
            == null) { // 两阶段验证
            Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);
            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
                   == null) {
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                    break;
            }
        }
    }
    return seg;
}

// ==================================== segment 内部实现 =====================================//

/**
* segment 内部 put方法
*/
final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    HashEntry<K,V> node = tryLock() ? null :
    scanAndLockForPut(key, hash, value); // 加锁
    
    V oldValue;
    try {
        HashEntry<K,V>[] tab = table;
        int index = (tab.length - 1) & hash;
        HashEntry<K,V> first = entryAt(tab, index); // 取entry数组中的元素
        for (HashEntry<K,V> e = first;;) {
            if (e != null) {
                // 寻找旧值, 并修改
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash && key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                
                
                if (node != null)
                    node.setNext(first);
                else
                    // 初始化entryValue
                    node = new HashEntry<K,V>(hash, key, value, first);
                 
                // 容量 + 1
                int c = count + 1;
                
                // 判断是否扩容
                if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    // 不扩容, 使用头插法直接赋值
                    setEntryAt(tab, index, node);
                
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}

/*
* 加锁不成功, 重试尝试加锁
*/
private HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {
    HashEntry<K,V> first = entryForHash(this, hash);
    HashEntry<K,V> e = first;
    HashEntry<K,V> node = null;
    int retries = -1; // negative while locating node
    while (!tryLock()) {
        // 在等待锁的过程中, 初始化hashEntry
        HashEntry<K,V> f; // to recheck first below
        if (retries < 0) {
            // 遍历链表, 寻找key
            if (e == null) {
                // 链表中没有key, 生成一个新hashEntry
                if (node == null) // speculatively create node
                    node = new HashEntry<K,V>(hash, key, value, null);
                retries = 0;
            }
            else if (key.equals(e.key))
                // 发现存在相同的key, 不需要初始化key
                retries = 0;
            else
                e = e.next;
        }
        else if (++retries > MAX_SCAN_RETRIES) {
            // 尝试次数过多, 开始进行阻塞加锁
            lock();
            break;
        }
        else if ((retries & 1) == 0 &&
                 (f = entryForHash(this, hash)) != first) {
            e = first = f; // map发生改变, 重新搜索key
            retries = -1;
        }
    }
    return node;
}
```

## 扩容

> 扩容只针对每个 `segment` 中的数组

```java
private void rehash(HashEntry<K,V> node) {

    HashEntry<K,V>[] oldTable = table; // 旧table
    int oldCapacity = oldTable.length;
    int newCapacity = oldCapacity << 1; // 新长度
    threshold = (int)(newCapacity * loadFactor); // 更新存储阈值
    HashEntry<K,V>[] newTable =
        (HashEntry<K,V>[]) new HashEntry[newCapacity]; // 新table
    int sizeMask = newCapacity - 1; // 新的桶严密
    for (int i = 0; i < oldCapacity ; i++) {
        // 遍历全部元素, 转移元素重新hash
        HashEntry<K,V> e = oldTable[i];
        if (e != null) {
            HashEntry<K,V> next = e.next;
            int idx = e.hash & sizeMask;
            if (next == null)   //  只有一个元素
                newTable[idx] = e;
            else { // Reuse consecutive sequence at same slot
                HashEntry<K,V> lastRun = e;
                int lastIdx = idx;
                // 从next节点开始遍历
                // 两次循环
                for (HashEntry<K,V> last = next;
                     last != null;
                     last = last.next) {
                    int k = last.hash & sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                newTable[lastIdx] = lastRun;
                // Clone remaining nodes
                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
                    V v = p.value;
                    int h = p.hash;
                    int k = h & sizeMask;
                    HashEntry<K,V> n = newTable[k];
                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);
                }
                // 两次循环结束
            }
        }
    }
    int nodeIndex = node.hash & sizeMask; // add the new node
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    table = newTable;
}
```

> 扩容里面有两次循环
>
> -  第一次循环是为了寻找从尾节倒序, 与尾节点转移时相同的链表,  这样做是为了第二次循环转移时, 不用遍历到链表尾部. (PS: 这么做不清楚对性能有什么好处, 可能这就是大佬们的实力吧)
>
> ![image-20210216161245393](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210216161245393.png)
>
> 如上图, 假设 绿色节点 和黄色节点, 会被转移到不同的哈希桶中, 第一次循环是为了找到指针的位置, 这样就可以只遍历到指针的位置就可以了
>
> - 第二次是单纯的转移对象

## get方法

```java
/*
* 直接遍历元素, 获取值. 没有加锁
*/
public V get(Object key) {
    Segment<K,V> s; // manually integrate access methods to reduce overhead
    HashEntry<K,V>[] tab;
    int h = hash(key);
    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
        (tab = s.table) != null) {
        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
             (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                return e.value;
        }
    }
    return null;
}
```

## remove方法

```java
public V remove(Object key) {
    int hash = hash(key);
    Segment<K,V> s = segmentForHash(hash);
    return s == null ? null : s.remove(key, hash, null);
}

// --------------  segment 内部实现 ---------------
final V remove(Object key, int hash, Object value) {
    if (!tryLock()) // 加锁
        scanAndLock(key, hash);
    V oldValue = null;
    try {
        HashEntry<K,V>[] tab = table;
        int index = (tab.length - 1) & hash;
        HashEntry<K,V> e = entryAt(tab, index);
        HashEntry<K,V> pred = null;
        while (e != null) {
            K k;
            HashEntry<K,V> next = e.next;
            // 遍历链表, 寻找key
            if ((k = e.key) == key ||
                (e.hash == hash && key.equals(k))) {
                V v = e.value;
                if (value == null || value == v || value.equals(v)) {
                    if (pred == null)
                        setEntryAt(tab, index, next);
                    else
                        pred.setNext(next);
                    ++modCount;
                    --count;
                    oldValue = v;
                }
                break;
            }
            pred = e;
            e = next;
        }
    } finally {
        unlock();
    }
    return oldValue;
}

private void scanAndLock(Object key, int hash) {
    // similar to but simpler than scanAndLockForPut , 与插入获取锁相似
    HashEntry<K,V> first = entryForHash(this, hash);
    HashEntry<K,V> e = first;
    int retries = -1;
    while (!tryLock()) {
        HashEntry<K,V> f;
        if (retries < 0) {
            if (e == null || key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        else if (++retries > MAX_SCAN_RETRIES) {
            lock();
            break;
        }
        else if ((retries & 1) == 0 &&
                 (f = entryForHash(this, hash)) != first) {
            e = first = f;
            retries = -1;
        }
    }
}
```

