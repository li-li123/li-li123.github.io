

## 前言

> 红黑树特性笔记: 
>
> 1. 每个节点要么是红色的要么是黑色的
> 2. 根节点的是黑色的
> 3. 如果一个节点是红色的,则它的两个儿子都是黑色的(**没有两个连续的红色节点**)
> 4. 对每个节点, 从该节点到其任意叶子节点的路径上,拥有相同数目的黑色节点
>
> ---
>
> 衍生特性(调整时从下往上依次调整)
>
> 1. 新节点插入时一定是红色
> 2. 父节点是黑色的,不需要调整
> 3. 父节点是红色的
>    1. 叔叔节点如果是空的, 需要进行**旋转 + 变色**
>    2. 叔叔节点如果是红色的,  需要把父节点和叔叔节点变成黑色, 祖父节点变成红色(根节点变成红色后, 会继续染色为黑色)
>    3. 叔叔节点是黑色的,  **旋转 + 变色**

## java 8 红黑树 插入源码

> AVL旋转参考-[AVL树的旋转图解和简单实现](https://www.jianshu.com/p/6988699625d5)

```java
static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,
                                                    TreeNode<K,V> x) {
    x.red = true; // 新节点默认为红色
    
    // xp 新节点的父节点, xpp 新节点的祖父节点, xppl 表示xpp的左孩子节点, xppr 表示xpp的右孩子节点
    for (TreeNode<K,V> xp, xpp, xppl, xppr;;) { 
        
        if ((xp = x.parent) == null) {// 判断父节点是否为空
            x.red = false;
            return x; // 插入根节点返回
        }
        else if (!xp.red || (xpp = xp.parent) == null) // 父节点是黑色或者调整到第二层,  不用继续调整
            return root;
        
        
        // 新节点的父节点是祖父节点的左孩子
        if (xp == (xppl = xpp.left)) {
            
            // 叔叔节点不为空且是红色的
            if ((xppr = xpp.right) != null && xppr.red) {
                xppr.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
                // 父节点和叔叔节点变黑, 祖父节点变红, 继续向上调整祖父节点
            }
            else { // 叔叔节点为空, 或者叔叔节点是黑色
                
                if (x == xp.right) { // 插入到父节点的右边, 修正成可以右旋的结构
                    root = rotateLeft(root, x = xp); // 不是左旋, 见图 1
                    xpp = (xp = x.parent) == null ? null : xp.parent; // 修正指针
                }
                if (xp != null) {
                    xp.red = false; // 右旋, 见图 2
                    if (xpp != null) {
                        xpp.red = true;
                        root = rotateRight(root, xpp);
                    }
                }
            }
        }
        else {
            if (xppl != null && xppl.red) {
                // 叔叔节点不为空且是红色的
                xppl.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
            }
            else {
                
                if (x == xp.left) { // 插入到父节点的左边, 修正成可以左旋的结构
                    root = rotateRight(root, x = xp); // 见图 3
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                if (xp != null) { // 左旋 见图 4
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;
                        root = rotateLeft(root, xpp);
                    }
                }
            }
        }
    }
}
```

> ![image-20210217161931040](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210217161931040.png)
>
> <center>图 1</center>
>
> ![image-20210217163910425](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210217163910425.png)
>
> <center>图 2</center>
>
> ![image-20210217164424313](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210217164424313.png)
>
> <center>图 3</center>
>
> ![image-20210217164451311](https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/image-20210217164451311.png)
>
> <center>图 4</center>





