> 本文摘自-[技术实验室-JVM触发GC时机](https://zhuanlan.zhihu.com/p/74081100)

由于堆内存中对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：**Minor GC和Full GC**

## Minor GC

从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。

首先我们了解下新创建的对象从新生代的Eden区到年老代的过程：

<center><img src="https://ning-wang.oss-cn-beijing.aliyuncs.com/blog-imags/v2-84ae4c36d650fde32380b08a910e381f_720w.png" alt="v2-84ae4c36d650fde32380b08a910e381f_720w"  /></center>

> 图中 黄色代表垃圾, 绿色代表未使用的空间, 红色代表还存活的对象

新生代分文一块较大的 Eden 空间, 和两块较小的 Survivor 空间(默认比例 `8:1:1` ), 每次分配只是用 Eden 和 其中一块 `Survivor`  当发生垃圾搜集时,将 Eden 和 Survivor 中仍存在的对象复制到另一个 Survivor 空间中, 然后直接清理 Eden 和那块用过的 Survivor. 



在 GC 开始的时候，对象只会存在于Eden区和名为 `From` 的 `Survivor` 区，`Survivor` 区 `To` 是空的。紧接着进行 GC，Eden 区中所有存活的对象都会被复制到 `To` ，而在 `From` 区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过 `-XX:MaxTenuringThreshold` 来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到 `To` 区域。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候, `From` 和 `To` 会交换他们的角色，也就是新的 `To` 就是上次 GC 前的`From`，新的 `From` 就是上次 GC 前的 `To`。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到`To` 区被填满，`To` 区被填满之后，会将所有对象移动到年老代中。

**触发条件：**一般情况下，当新对象生成，并且在 Eden 区满时，就会触发 Minor GC ，对 Eden 区域进行GC， 清除非存活对象，并且把尚且存活的对象移动到 Survivor 区。然后整理 Survivor 的两个区。这种方式的 GC 是对年轻代的 Eden 区进行，不会影响到年老代。因为大部分对象都是从 Eden 区开始的，同时E den 区不会分配的很大，所以 Eden 区的 GC 会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

## Full GC

对整个堆进行整理，包括年轻代、年老代和永久代。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：

**满足任意一个触发条件：**

- 当 Eden 区和 From Survivor 区满时
- 老年代空间不足
- 方法区空间不足
- System.gc() 被显示调用
- 由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。