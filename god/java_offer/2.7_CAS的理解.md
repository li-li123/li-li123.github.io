## 什么是 CAS

`CAS` 即 `Compare And Swap` 的缩写，翻译成中文就是**比较并交换**，其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是CAS是**原子性**的操作(读和写两者同时具有原子性)，其实现方式是通过借助`C/C++`调用CPU指令完成的，所以效率很高。
 `CAS`的原理很简单，这里使用一段`Java`代码来描述

```java
public boolean compareAndSwap(int value, int expect, int update) {
//        如果内存中的值value和期望值expect一样 则将值更新为新值update
    if (value == expect) {
        value = update;
        return true;
    } else {
        return false;
    }
}
```

大致过程是将内存中的值、我们的期望值、新值交给CPU进行运算，如果内存中的值和我们的期望值相同则将值更新为新值，否则不做任何操作。这个过程是在CPU中完成的，这里不好描述CPU的工作过程，就拿Java代码来描述了。

## CAS 的优点

* 竞争不大的时候系统开销小

## CAS 的缺点

* 循环时间长开销大
* ABA 问题

> ABA问题是无锁结构实现中常见的一种问题，可基本表述为：
>
> 1. 进程P1读取了一个数值A
> 2. P1被挂起(时间片耗尽、中断等)，进程P2开始执行
> 3. P2修改数值A为数值B，然后又修改回A
> 4. P1被唤醒，比较后发现数值A没有变化，程序继续执行。
>
> 对于P1来说，数值A未发生过改变，但实际上A已经被变化过了，继续使用可能会出现问题。在CAS操作中，由于比较的多是指针，这个问题将会变得更加严重。试想如下情况：
>
> ```ascii
>    top
>     |
>     V   
>   0x0014
> | Node A | --> |  Node X | --> ……
> ```
>
> 有一个栈(先入后出)中有top和节点A，节点A目前位于栈顶top指针指向A。现在有一个进程P1想要pop一个节点，因此按照如下无锁操作进行
>
> ```java
> pop()
> {
>   do{
>     ptr = top;            // ptr = top = NodeA
>     next_prt = top->next; // next_ptr = NodeX
>   } while(CAS(top, ptr, next_ptr) != true);
>   return ptr;   
> }
> ```
>
> 而进程P2在执行CAS操作之前打断了P1，并对栈进行了一系列的pop和push操作，使栈变为如下结构：
>
> ```
>    top
>     |
>     V  
>   0x0014
> | Node C | --> | Node B | --> |  Node X | --> ……
> ```
>
> 进程P2首先pop出NodeA，之后又Push了两个NodeB和C，由于内存管理机制中广泛使用的内存重用机制，导致NodeC的地址与之前的NodeA一致。
>
> 这时P1又开始继续运行，在执行CAS操作时，由于top依旧指向的是NodeA的地址(实际上已经变为NodeC)，因此将top的值修改为了NodeX，这时栈结构如下：
>
> ```
>                                    top
>                                     |
>    0x0014                           V
>  | Node C | --> | Node B | --> |  Node X | --> ……
> ```
>
> 经过 `CAS` 操作后, top 指针错误的指向 NodeX 而不是 NodeB

* 只能保证一个共享变量的原子操作