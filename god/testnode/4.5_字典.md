# 字典
字典：通过键(key)存储对象的一种映射。映射并没有维护任何可靠地从左至右的顺序。他们简单的将键映射到相应的值上。
### 映射操作
1. 字典可以作为常量编写在大括号中，并包含一系列的“键：值”
```pthon
>>> D ={'food':'Spam','quantity':4,'color':'pink'}
>>> D
{'food': 'Spam', 'quantity': 4, 'color': 'pink'}
```
2. 通过键对这个字典进行索引来读取或改变键所对应的value值。字典的索引操作使用时和序列相同的语法，单在方括号中的元素时间，而不是相应的为值。
```python
>>> D = {}
>>> D['name'] = 'Bob'
>>> D['job'] = 'dev'
>>> D['age'] = 40
>>> D
{'name': 'Bob', 'job': 'dev', 'age': 40}
>>> D['name']
'Bob'
```
此处我们通过键索引字典中的值，同样也是通过键存储数据。
4. 我们同样可以通过向dict类型名中传递键值参数对（一种在函数调用时特殊的name = value的语法），或者传递在运行时将键和值的序列进行zip配对的结果（例如从文件中读取）来创建字典，以下两种方式和之前的例子创建了一样的字典以及相应等价的{}字面量形式，单第一种方法可以打更少的子：
```python
>>> bob2 = dict(zip(['name','job','age'],['Bob','dev',40]))
>>> bob2
{'name': 'Bob', 'job': 'dev', 'age': 40}
>>> bob2 = dict(zip(['name','job','age'],['Bob','dev',40]))
```
python中zip（）函数是用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少内存。
如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同
```python
>>> a= ('a','b','c')
>>> b = (1,2,3)
>>> d = list(zip(a,b))
>>> d
[('a', 1), ('b', 2), ('c', 3)]
```
#### 思路：
先利用zip（）函数将两个列表打包成一个元组对象，在利用dict/list 来构造相应的数据类型
### 重放嵌套
1. 我们可以通过字典去记录一个人的基本信息，以上记录都是相对来说比较简单的。如下假设所要记录的人的信息更加复杂，比如需要记录名和姓、记录多个职位等，如此一来需要使用python对象嵌套。，如下所示可以通过字典一次性将所有信息都编写如一个常量，记录更多的结构化信息。
```python
>>> rec = {'name':{'first':'Bob','last':'Smith'},'job':{'dev','age'},'age':40.5}
>>> rec
{'name': {'first': 'Bob', 'last': 'Smith'}, 'job': {'dev', 'age'}, 'age': 40.5}

>>> rec = {'name':{'first':'Bob','last':'Smith'},'job':['dev','age'],'age':40.5}
>>> rec
{'name': {'first': 'Bob', 'last': 'Smith'}, 'job': ['dev', 'age'], 'age': 40.5}
```
 思路：
在这里，在顶层再次使用了三个键的字典（键分别是‘name’，‘job’和age），但是值的更复杂了，一个嵌套的字典作为name的值，支持多个部分，并用一个嵌套的列表作为job的值，从而支持多个角色和未来的扩展。我们能够获取这个结构的组件，就像之前在基于列表的矩阵中所做的那样，但是这次大部分的索引是字典的键，而不是列表的偏移量。
```python
>>> rec = {'name':{'first':'Bob','last':'Smith'},'job':['dev','age'],'age':40.5}
>>> rec
{'name': {'first': 'Bob', 'last': 'Smith'}, 'job': ['dev', 'age'], 'age': 40.5}
>>> rec['name']
{'first': 'Bob', 'last': 'Smith'}
>>> rec['name']['last']
'Smith'
>>> rec['job']
['dev', 'age']
>>> rec['job'][-1]
'age'
>>>

>>> rec['job'].append('janitor')
>>> rec
{'name': {'first': 'Bob', 'last': 'Smith'}, 'job': ['dev', 'age', 'janitor'], 'age': 40.5}
>>> rec['job'][-1] = 'mgr'
>>> rec
{'name': {'first': 'Bob', 'last': 'Smith'}, 'job': ['dev', 'age', 'mgr'], 'age': 40.5}
>>>
```
 思路：
  rec['job'].append('janitor')是扩展job列表，因为job列表是字典所包含的一部分独立的内存，他可以自由地增加或减少
  rec['job'][-1] = 'mgr' 可以修改job列表中的数据
2. 在底层语言中我们不需要的对象需要小心释放，但是在Python中，当最后一次引用对象后（比如将这个变量用其他的值进行赋值），这个对象所占用的内存空间将会自动清理掉。
```python
>>> rec
{'name': {'first': 'Bob', 'last': 'Smith'}, 'job': ['dev', 'age', 'mgr'], 'age': 40.5}
>>> rec = 0
>>> rec
0
```
4. 
