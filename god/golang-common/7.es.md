## 1. 下载依赖

```shell
go get -u github.com/olivere/elastic/v7
```

## 2. 相关代码

### 2.1 初始化
```go
func initEs(config config.ESConfig) {
	esURL := config.URL
	esUsername := config.Username
	esPassword := config.Password
	client, err := elastic.NewClient(
		elastic.SetURL(esURL),
		elastic.SetBasicAuth(esUsername, esPassword),
		elastic.SetSniff(false), // 关闭节点自动探测
	)
	if err != nil {
		panic(err)
	}
	resource.EsClient = client
}
```

### 2.2 数据操作
```go
package es

import (
	"context"
	"sync"
	"time"

	"github.com/olivere/elastic/v7"
	log "github.com/sirupsen/logrus"

	"mikan/internal/resource"
)

const (
	LogPrefix = "golang-log-"
)

var (
	bulkIndexList = make([]elastic.BulkableRequest, 0)
	bulkIndexChan = make(chan elastic.BulkableRequest, 1000)
	lock          sync.Mutex
	ticker        *time.Ticker
	quit          chan struct{}
)

func init() {
	go bulkIndex()
	ticker = time.NewTicker(5 * time.Second)
	quit = make(chan struct{})
	// 每5秒钟推数据至ES
	go func() {
		for {
			select {
			case <-ticker.C:
				lock.Lock()
				if len(bulkIndexList) > 0 {
					_, err := resource.EsClient.Bulk().Add(bulkIndexList...).Do(context.Background())
					if err != nil {
						log.Warnf("bulk index error %v", err)
					}
					bulkIndexList = make([]elastic.BulkableRequest, 0)
				}
				lock.Unlock()
			case <-quit:
				ticker.Stop()
				return
			}
		}
	}()

}

// bulkIndex 数据超过一定规模后推送至ES
func bulkIndex() {
	for bulkReq := range bulkIndexChan {
		lock.Lock()
		bulkIndexList = append(bulkIndexList, bulkReq)
		if len(bulkIndexList) >= 100 {
			_, err := resource.EsClient.Bulk().Add(bulkIndexList...).Do(context.Background())
			if err != nil {
				log.Warnf("bulk index error %v", err)
			}
			bulkIndexList = make([]elastic.BulkableRequest, 0)
		}
		lock.Unlock()
	}
}

type Service struct {
}

func NewService() *Service {
	return &Service{}
}

// 单条插入
func (s *Service) IndexDoc(index string, id string, doc interface{}) error {
	if id == "" {
		_, err := resource.EsClient.Index().Index(index).BodyJson(doc).Do(context.Background())
		return err
	}
	_, err := resource.EsClient.Index().Index(index).Id(id).BodyJson(doc).Do(context.Background())
	return err
}

// CommitAllIndex 提交全部数据
func (s *Service) CommitAllIndex() {
	lock.Lock()
	defer lock.Unlock()
	if len(bulkIndexList) > 0 {
		_, err := resource.EsClient.Bulk().Add(bulkIndexList...).Do(context.Background())
		if err != nil {
			log.Warnf("bulk index error %v", err)
		}
		bulkIndexList = make([]elastic.BulkableRequest, 0)
	}
}

// 批量插入
func (s *Service) BulkIndexDoc(index string, id string, doc interface{}) {
	var bulkReq elastic.BulkableRequest
	if id == "" {
		bulkReq = elastic.NewBulkIndexRequest().Index(index).Doc(doc)
	} else {
		bulkReq = elastic.NewBulkIndexRequest().Index(index).Id(id).Doc(doc)
	}
	bulkIndexChan <- bulkReq
}

// BulkLog 批量插入日志
func (s *Service) BulkLog(id string, doc interface{}) {
	bulkReq := elastic.NewBulkIndexRequest().Index(LogPrefix + time.Now().Format("2006.01.02")).Id(id).Doc(doc)
	bulkIndexChan <- bulkReq
}

// IndexLog 单条插入日志
func (s *Service) IndexLog(id string, doc interface{}) error {
	_, err := resource.EsClient.Index().
		Index(LogPrefix + time.Now().Format("2006.01.02")).
		Id(id).
		BodyJson(doc).
		Do(context.Background())

	return err
}

// QueryLog 查询日志
func (s *Service) QueryLog(jobKey string, startTime time.Time, endTime time.Time, limit, size int ) (*elastic.SearchResult, error) {
	query := elastic.NewBoolQuery()
	if jobKey != "" {
		query.Must(elastic.NewTermQuery("jobKey.keyword", jobKey))
	}
	startTimeStr := startTime.UTC().Format("2006-01-02T15:04:05.000Z")
	endTimeStr := endTime.UTC().Format("2006-01-02T15:04:05.000Z")
	query.Must(elastic.NewRangeQuery("timestamp").Gte(startTimeStr).Lte(endTimeStr))
	searchResult, err := resource.EsClient.Search().
		Index(LogPrefix + time.Now().Format("2006.01.02")).
		Query(query).
		From(limit).
		Size(size).
		Do(context.Background())
	return searchResult, err
}

```